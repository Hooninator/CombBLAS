import time
import scipy as sc

import sys
sys.path.append('/home/spr/kdt/trunk/Python/pyCombBLAS')
sys.path.append('/home/spr/kdt/trunk/Python/distribCombBLAS')

import pyCombBLAS as pcb
import DiGraph as kdtdg
#from DiGraph import DiGraph

def k2Validate(G, start, parents):
	good = True;
	
	(valid, levels) = kdtdg.isBfsTree(G, start, parents);
	#	isBfsTree implements Graph500 tests 1 and 2 
	if valid < 0:
		print "isBfsTree detected failure of Graph500 test %d" % abs(valid);
		good = False;
	return good;
####NOTE:  rest of routine is dead code!!    pending SPM.find() implementation

	# Spec test #3:
	# every input edge has vertices whose levels differ by no more than 1
	# NOTE:  code implements every _tree_ edge, not input edge
#FIX:  visited not calculated yet
	if any((parents <> -1) & (visited <> 1)):
		print "The levels of some input edges' vertices differ by more than 1"
		good = False;

	# Spec test #4:
	# the BFS tree spans a connected component's vertices (== all edges either
	# have both endpoints in the tree or not in the tree)
	#FIND [[Gi,Gj],Gv] = G.find();
	li = levels[Gi]; 
	lj = levels[Gj];
	neither_in = (li == -1) & (lj == -1);
	both_in = (li > -1) & (lj > -1);
	if (~(neither_in | both_in)).any():
		print "The tree does not span exactly the connected component"
		good = False;

	# Spec test #5:
	# a vertex and its parent are joined by an edge of the original graph
	respects = abs(li-lj) <= 1
	if (~(neither_in | respects)).any():
		print "At least one vertex and its parent are not joined by an original edge"
		good = False;

	return good;



scale = 10;

G = kdtdg.DiGraph();
degrees = kdtdg.ParVec.zeros(4);
K1elapsed = G.genGraph500Edges(scale, degrees);

#	indices of vertices with degree > 2
nstarts = 4;
deg3verts = (G.degree() > 2).findInds();
starts = sc.random.randint(0,high=len(deg3verts),size=(nstarts,));
# deg3verts stays distributed; indices to it (starts) are scalars

K2elapsed = 1e-12;
K2edges = 0;
for start in starts:
	start = int(start);
	before = time.clock();
	parents = kdtdg.bfsTree(G, start);
	K2elapsed += time.clock() - before;
	if not k2Validate(G, start, parents):
		print "Invalid BFS tree generated by bfsTree";
		break;
	#FIX:  when G.find() is available, to create edges, use next lime
	# K2edges += len((parents[edges.verts()[0]] <> -2).nonzero());
	K2edges += 1000;

if kdtdg.master():
	print "\n	***Timings invalid;  #traversed edges not calculated properly\n"
	print 'Graph500 benchmark run for scale = %2i' % scale
	print 'Kernel 1 time = %8.4f seconds' % K1elapsed
	print 'Kernel 2 time = %8.4f seconds' % K2elapsed
	print '                    %8.4f seconds for each of %i starts' % (K2elapsed/nstarts, nstarts)
	print 'Kernel 2 TEPS = %7.4e' % (K2edges/K2elapsed)
