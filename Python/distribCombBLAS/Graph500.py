import time
import scipy as sc
import pyCombBLAS as pcb
import PyCombBLAS as PCB
import DiGraph as kdtdg
#from DiGraph import DiGraph

def k2Validate(G, start, parents):
	good = True;
	
	(valid, levels) = kdtdg.isBfsTree(G, start, parents);
	#	isBfsTree implements Graph500 tests 1 and 2 
	if valid < 0:
		print "isBfsTree detected failure of Graph500 test %d" % abs(valid);
		good = False;
	return good;
####NOTE:  rest of routine is dead code!!    pending SPM.find() implementation

	# Spec test #3:
	# every input edge has vertices whose levels differ by no more than 1
	# NOTE:  code implements every _tree_ edge, not input edge
#FIX:  visited not calculated yet
	if any((parents <> -2) & (visited <> 1)):
		print "The levels of some input edges' vertices differ by more than 1"
		good = False;

	# Spec test #4:
	# the BFS tree spans a connected component's vertices (== all edges either
	# have both endpoints in the tree or not in the tree)
	#[[Gi,Gj],Gv] = G._toVectors(G.spmat)
	li = levels[Gi]; 
	lj = levels[Gj];
	neither_in = (li == -2) & (lj == -2);
	both_in = (li > -2) & (lj > -2);
	if any(~(neither_in | both_in)):
		print "The tree does not span exactly the connected component"
		good = False;

	# Spec test #5:
	# a vertex and its parent are joined by an edge of the original graph
	respects = abs(li-lj) <= 1
	if any(~(neither_in | respects)):
		print "At least one vertex and its parent are not joined by an original edge"
		good = False;

	return good;



scale = 4;

G = kdtdg.DiGraph();
K1elapsed = kdtdg.genGraph500Edges(G, scale);
#FIX: genGraph500Edges not returning the time properly
K1elapsed = 1.0;

#	indices of vertices with degree > 2
nstarts = 4;
G500CANDS_BUILTIN = True;
if not G500CANDS_BUILTIN:
	deg3verts = (G.degree() > 2).nonzero();
	starts = np.random.randint(0,high=len(deg3verts),size=(nstarts,));
	# deg3verts stays distributed; indices to it (starts) are scalars
else:
	starts = kdtdg.genGraph500Candidates(G, nstarts);
K2elapsed = 1e-12;
K2edges = 0;
for start in starts:
	before = time.clock();
	parents = kdtdg.bfsTree(G, start);
	K2elapsed += time.clock() - before;
	if not k2Validate(G, start, parents):
		print "Invalid BFS tree generated by bfsTree";
		break;
	#FIX:  when G.find() is available, to create edges, use next lime
	# K2edges += len((parents[edges.verts()[0]] <> -2).nonzero());
	K2edges += 1000;

print "\n	***Timings invalid;  #traversed edges not calculated properly\n"
print 'Graph500 benchmark run for scale = %2i' % scale
print 'Kernel 1 time = %8.4f seconds' % K1elapsed
print 'Kernel 2 time = %8.4f seconds' % K2elapsed
print '                    %8.4f seconds for each of %i starts' % (K2elapsed/nstarts, nstarts)
print 'Kernel 2 TEPS = %7.4e' % (K2edges/K2elapsed)
