
%module pyCombBLAS

//%typemap(in) int64_t = long long;
//%typemap(out) int64_t = long long;
%apply long long {int64_t}

// This block gets copied verbatim into the header area of the generated wrapper.

%{
#define SWIG_FILE_WITH_INIT

#define NO_SWIGPYRUN
#include "pyCombBLAS.h"
%}


// This block gets called when the module is loaded. It is wrapped in extern "C".
%init %{
init_pyCombBLAS_MPI();

/* These are necessary because the file generated by `swig -python -external-runtime` doesn't
   include the type info. SWIG types are needed by nearly every call to a SWIG function
   (eg. SWIG_ConvertPtr). The SWIG docs don't mention how these types are to be obtained,
   so I copy them over from the _wrap.cpp file here.
*/
SWIG_Obj1Info = SWIGTYPE_p_Obj1;
SWIG_Obj2Info = SWIGTYPE_p_Obj2;
%}


// Language independent exception handler
%include exception.i    

%exception {
	try {
		$action
	} catch(string& stringReason) {
		const char* sData = (char*)stringReason.c_str();
		SWIG_exception(SWIG_RuntimeError,sData);
		SWIG_exception(SWIG_IndexError,sData);
	} catch(...) {
		SWIG_exception(SWIG_RuntimeError,"Unknown exception");
	}
}

// Grab a Python function object as a Python object.
// Based on example from SWIG docs: http://www.swig.org/Doc1.1/HTML/Python.html#n11
#ifdef SWIG<python>
%typemap(in) PyObject *pyfunc {
  if (!PyCallable_Check($input)) {
      PyErr_SetString(PyExc_TypeError, "Need a callable object!");
      return NULL;
  }
  $1 = $input;
}

%typemap(in) PyObject* {
  $1 = $input;
}

#else
 // #warning Please define a way to handle callbacks in your target language.
#endif

// wrapped classes

class pySpParMat {
public:
	pySpParMat();
	pySpParMat(int64_t m, int64_t n, pyDenseParVec* rows, pyDenseParVec* cols, pyDenseParVec* vals);

	pySpParMat(const pySpParMat& copyFrom);
	pySpParMat(const pySpParMatBool& copyStructureFrom);
	pySpParMat(const pySpParMatObj1& copyStructureFrom);
	pySpParMat(const pySpParMatObj2& copyStructureFrom);
	
public:
	int64_t getnnz();
	int64_t getnee();
	int64_t getnrow();
	int64_t getncol();
	
public:	
	void load(const char* filename, bool pario);
	void save(const char* filename);
	
	double GenGraph500Edges(int scale, pyDenseParVec* pyDegrees = NULL, int EDGEFACTOR = 16, bool delIsolated=true, double a=.57, double b=.19, double c=.19, double d=.05);
	//double GenGraph500Edges(int scale, pyDenseParVec& pyDegrees);
	
public:
	pySpParMat copy();

	pySpParMat& assign(const pySpParMat& other);
	pySpParMat SubsRef(const pyDenseParVec& rows, const pyDenseParVec& cols, bool inPlace, op::UnaryPredicateObj* matFilter);
	
	int64_t removeSelfLoops();
	
	void Apply(op::UnaryFunction* f);
	void Apply(op::UnaryFunctionObj* f);
	void DimWiseApply(int dim, const pyDenseParVec& values, op::BinaryFunction* f);
	void DimWiseApply(int dim, const pyDenseParVec& values, op::BinaryFunctionObj* f);
	pySpParMat Keep(op::UnaryPredicateObj* f, bool inPlace);

	int64_t Count(op::UnaryFunction* pred);
	
	// Be wary of identity value with min()/max()!!!!!!!
	pyDenseParVec Reduce(int dim, op::BinaryFunction* f, double identity = 0);
	pyDenseParVec Reduce(int dim, op::BinaryFunction* bf, op::UnaryFunction* uf, double identity = 0);
	void Reduce(int dim, pyDenseParVec* ret, op::BinaryFunctionObj* bf, op::UnaryFunctionObj* uf, double identity = 0);

	void Transpose();
	//void EWiseMult(pySpParMat* rhs, bool exclude);

	void Find(pyDenseParVec* outrows, pyDenseParVec* outcols, pyDenseParVec* outvals) const;
public:
	pySpParVec     SpMV(const pySpParVec&     x, op::SemiringObj* sring);
	pySpParVecObj1 SpMV(const pySpParVecObj1& x, op::SemiringObj* sring);
	pySpParVecObj2 SpMV(const pySpParVecObj2& x, op::SemiringObj* sring);
	pyDenseParVec     SpMV(const pyDenseParVec&     x, op::SemiringObj* sring);
	pyDenseParVecObj1 SpMV(const pyDenseParVecObj1& x, op::SemiringObj* sring);
	pyDenseParVecObj2 SpMV(const pyDenseParVecObj2& x, op::SemiringObj* sring);

	void SpMV_inplace(pySpParVec&     x, op::SemiringObj* sring);
	void SpMV_inplace(pySpParVecObj1& x, op::SemiringObj* sring);
	void SpMV_inplace(pySpParVecObj2& x, op::SemiringObj* sring);
	void SpMV_inplace(pyDenseParVec&     x, op::SemiringObj* sring);
	void SpMV_inplace(pyDenseParVecObj1& x, op::SemiringObj* sring);
	void SpMV_inplace(pyDenseParVecObj2& x, op::SemiringObj* sring);

	void Square(op::SemiringObj* sring);
	pySpParMat     SpGEMM(pySpParMat     &other, op::SemiringObj* sring);
	pySpParMatBool SpGEMM(pySpParMatBool &other, op::SemiringObj* sring);
	pySpParMatObj1 SpGEMM(pySpParMatObj1 &other, op::SemiringObj* sring);
	pySpParMatObj2 SpGEMM(pySpParMatObj2 &other, op::SemiringObj* sring);
	
public:
	static int Column() { return ::Column; }
	static int Row() { return ::Row; }
};

pySpParMat EWiseApply(const pySpParMat& A, const pySpParMat&     B, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, double ANull, double BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParMat EWiseApply(const pySpParMat& A, const pySpParMatBool& B, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, double ANull, bool   BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParMat EWiseApply(const pySpParMat& A, const pySpParMatObj1& B, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, double ANull, const Obj1& BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParMat EWiseApply(const pySpParMat& A, const pySpParMatObj2& B, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, double ANull, const Obj2& BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);



class pySpParMatBool {
public:
	pySpParMatBool();
	pySpParMatBool(int64_t m, int64_t n, pyDenseParVec* rows, pyDenseParVec* cols, pyDenseParVec* vals);
	
	pySpParMatBool(const pySpParMat    & copyStructureFrom);
	pySpParMatBool(const pySpParMatBool& copyStructureFrom);
	pySpParMatBool(const pySpParMatObj1& copyStructureFrom);
	pySpParMatBool(const pySpParMatObj2& copyStructureFrom);

public:
	int64_t getnnz();
	int64_t getnee();
	int64_t getnrow();
	int64_t getncol();
	
public:	
	void load(const char* filename, bool pario);
	void save(const char* filename);
	
	double GenGraph500Edges(int scale, pyDenseParVec* pyDegrees = NULL, int EDGEFACTOR=16, bool delIsolated=true, double a=.57, double b=.19, double c=.19, double d=.05);
	//double GenGraph500Edges(int scale, pyDenseParVec& pyDegrees);
	
public:
	pySpParMatBool copy();

	pySpParMatBool& assign(const pySpParMatBool& other);
	pySpParMatBool SpGEMM(pySpParMatBool& other);
	pySpParMatBool SubsRef(const pyDenseParVec& rows, const pyDenseParVec& cols, bool inPlace, op::UnaryPredicateObj* matFilter);
	
	int64_t removeSelfLoops();
	
	void Apply(op::UnaryFunction* f);
	//void DimWiseApply(int dim, const pyDenseParVec& values, op::BinaryFunctionObj* f); // Not enough CombBLAS support
	pySpParMatBool Keep(op::UnaryPredicateObj* f, bool inPlace);

	int64_t Count(op::UnaryFunction* pred);
	
	// Be wary of identity value with min()/max()!!!!!!!
	pyDenseParVec Reduce(int dim, op::BinaryFunction* f, double identity = 0);
	pyDenseParVec Reduce(int dim, op::BinaryFunction* bf, op::UnaryFunction* uf, double identity = 0);
	void Reduce(int dim, pyDenseParVec* ret, op::BinaryFunctionObj* bf, op::UnaryFunctionObj* uf, double identity = 0);

	void Transpose();
	//void EWiseMult(pySpParMatBool rhs, bool exclude);

	void Find(pyDenseParVec* outrows, pyDenseParVec* outcols, pyDenseParVec* outvals) const;
public:
	pySpParVec     SpMV(const pySpParVec&     x, op::SemiringObj* sring);
	pySpParVecObj1 SpMV(const pySpParVecObj1& x, op::SemiringObj* sring);
	pySpParVecObj2 SpMV(const pySpParVecObj2& x, op::SemiringObj* sring);
	pyDenseParVec     SpMV(const pyDenseParVec&     x, op::SemiringObj* sring);
	pyDenseParVecObj1 SpMV(const pyDenseParVecObj1& x, op::SemiringObj* sring);
	pyDenseParVecObj2 SpMV(const pyDenseParVecObj2& x, op::SemiringObj* sring);

	void SpMV_inplace(pySpParVec&     x, op::SemiringObj* sring);
	void SpMV_inplace(pySpParVecObj1& x, op::SemiringObj* sring);
	void SpMV_inplace(pySpParVecObj2& x, op::SemiringObj* sring);
	void SpMV_inplace(pyDenseParVec&     x, op::SemiringObj* sring);
	void SpMV_inplace(pyDenseParVecObj1& x, op::SemiringObj* sring);
	void SpMV_inplace(pyDenseParVecObj2& x, op::SemiringObj* sring);

	void Square(op::SemiringObj* sring);
	pySpParMat     SpGEMM(pySpParMat     &other, op::SemiringObj* sring);
	pySpParMatBool SpGEMM(pySpParMatBool &other, op::SemiringObj* sring);
	pySpParMatObj1 SpGEMM(pySpParMatObj1 &other, op::SemiringObj* sring);
	pySpParMatObj2 SpGEMM(pySpParMatObj2 &other, op::SemiringObj* sring);


public:
	static int Column() { return ::Column; }
	static int Row() { return ::Row; }
};

pySpParMatBool EWiseApply(const pySpParMatBool& A, const pySpParMat&     B, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, bool ANull, double BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParMatBool EWiseApply(const pySpParMatBool& A, const pySpParMatBool& B, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, bool ANull, bool   BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParMatBool EWiseApply(const pySpParMatBool& A, const pySpParMatObj1& B, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, bool ANull, const Obj1& BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParMatBool EWiseApply(const pySpParMatBool& A, const pySpParMatObj2& B, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, bool ANull, const Obj2& BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);


class pySpParMatObj1 {
public:
	pySpParMatObj1();
	pySpParMatObj1(int64_t m, int64_t n, pyDenseParVec* rows, pyDenseParVec* cols, pyDenseParVecObj1* vals);

public:
	//int64_t getnnz();
	int64_t getnee();
	int64_t getnrow() const;
	int64_t getncol() const;
	
public:	
	void load(const char* filename, bool pario);
	void save(const char* filename);
	
	//double GenGraph500Edges(int scale, pyDenseParVec* pyDegrees = NULL, int EDGEFACTOR = 16);
	//double GenGraph500Edges(int scale, pyDenseParVec& pyDegrees);
	
public:
	pySpParMatObj1 copy();

	pySpParMatObj1& assign(const pySpParMatObj1& other);
	pySpParMatObj1 SubsRef(const pyDenseParVec& rows, const pyDenseParVec& cols, bool inPlace, op::UnaryPredicateObj* matFilter);
	
	int64_t removeSelfLoops();
	
	void Apply(op::UnaryFunctionObj* f);
	void DimWiseApply(int dim, const pyDenseParVecObj1& values, op::BinaryFunctionObj* f);
	pySpParMatObj1 Keep(op::UnaryPredicateObj* pred, bool inPlace);
	
	// Be wary of identity value with min()/max()!!!!!!!
	void Reduce(int dim, pyDenseParVec     *ret, op::BinaryFunctionObj* bf, op::UnaryFunctionObj* uf, double identity = 0);
	void Reduce(int dim, pyDenseParVecObj1 *ret, op::BinaryFunctionObj* bf, op::UnaryFunctionObj* uf, Obj1 identity = Obj1());
	//void Reduce(int dim, pyDenseParVecObj2 ret, op::BinaryFunctionObj* bf, op::UnaryFunctionObj* uf, Obj2 identity = Obj2());
	
	void Transpose();

	void Find(pyDenseParVec* outrows, pyDenseParVec* outcols, pyDenseParVecObj1* outvals) const;
public:
	pySpParVec     SpMV(const pySpParVec&     x, op::SemiringObj* sring);
	pySpParVecObj1 SpMV(const pySpParVecObj1& x, op::SemiringObj* sring);
	pySpParVecObj2 SpMV(const pySpParVecObj2& x, op::SemiringObj* sring);
	pyDenseParVec     SpMV(const pyDenseParVec&     x, op::SemiringObj* sring);
	pyDenseParVecObj1 SpMV(const pyDenseParVecObj1& x, op::SemiringObj* sring);
	pyDenseParVecObj2 SpMV(const pyDenseParVecObj2& x, op::SemiringObj* sring);

	void SpMV_inplace(pySpParVec&     x, op::SemiringObj* sring);
	void SpMV_inplace(pySpParVecObj1& x, op::SemiringObj* sring);
	void SpMV_inplace(pySpParVecObj2& x, op::SemiringObj* sring);
	void SpMV_inplace(pyDenseParVec&     x, op::SemiringObj* sring);
	void SpMV_inplace(pyDenseParVecObj1& x, op::SemiringObj* sring);
	void SpMV_inplace(pyDenseParVecObj2& x, op::SemiringObj* sring);

	void Square(op::SemiringObj* sring);
	pySpParMat     SpGEMM(pySpParMat     &other, op::SemiringObj* sring);
	pySpParMatBool SpGEMM(pySpParMatBool &other, op::SemiringObj* sring);
	pySpParMatObj1 SpGEMM(pySpParMatObj1 &other, op::SemiringObj* sring);
	pySpParMatObj2 SpGEMM(pySpParMatObj2 &other, op::SemiringObj* sring);

public:
	static int Column() { return ::Column; }
	static int Row() { return ::Row; }
};

pySpParMatObj1 EWiseApply(const pySpParMatObj1& A, const pySpParMat&     B, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, const Obj1& ANull, double BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParMatObj1 EWiseApply(const pySpParMatObj1& A, const pySpParMatBool& B, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, const Obj1& ANull, bool   BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParMatObj1 EWiseApply(const pySpParMatObj1& A, const pySpParMatObj1& B, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, const Obj1& ANull, const Obj1& BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParMatObj1 EWiseApply(const pySpParMatObj1& A, const pySpParMatObj2& B, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, const Obj1& ANull, const Obj2& BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);


class pySpParMatObj2 {
public:
	pySpParMatObj2();
	pySpParMatObj2(int64_t m, int64_t n, pyDenseParVec* rows, pyDenseParVec* cols, pyDenseParVecObj2* vals);

public:
	//int64_t getnnz();
	int64_t getnee();
	int64_t getnrow() const;
	int64_t getncol() const;
	
public:	
	void load(const char* filename, bool pario);
	void save(const char* filename);
	
	//double GenGraph500Edges(int scale, pyDenseParVec* pyDegrees = NULL, int EDGEFACTOR = 16);
	//double GenGraph500Edges(int scale, pyDenseParVec& pyDegrees);
	
public:
	pySpParMatObj2 copy();

	pySpParMatObj2& assign(const pySpParMatObj2& other);
	pySpParMatObj2 SubsRef(const pyDenseParVec& rows, const pyDenseParVec& cols, bool inPlace, op::UnaryPredicateObj* matFilter);
	
	int64_t removeSelfLoops();
	
	void Apply(op::UnaryFunctionObj* f);
	void DimWiseApply(int dim, const pyDenseParVecObj2& values, op::BinaryFunctionObj* f);
	pySpParMatObj2 Keep(op::UnaryPredicateObj* pred, bool inPlace);
	
	// Be wary of identity value with min()/max()!!!!!!!
	void Reduce(int dim, pyDenseParVec     *ret, op::BinaryFunctionObj* bf, op::UnaryFunctionObj* uf, double identity = 0);
	void Reduce(int dim, pyDenseParVecObj2 *ret, op::BinaryFunctionObj* bf, op::UnaryFunctionObj* uf, Obj2 identity = Obj2());
	//void Reduce(int dim, pyDenseParVecObj1 ret, op::BinaryFunctionObj* bf, op::UnaryFunctionObj* uf, Obj1 identity = Obj1());
	
	void Transpose();

	void Find(pyDenseParVec* outrows, pyDenseParVec* outcols, pyDenseParVecObj2* outvals) const;
public:
	pySpParVec     SpMV(const pySpParVec&     x, op::SemiringObj* sring);
	pySpParVecObj2 SpMV(const pySpParVecObj2& x, op::SemiringObj* sring);
	pySpParVecObj1 SpMV(const pySpParVecObj1& x, op::SemiringObj* sring);
	pyDenseParVec     SpMV(const pyDenseParVec&     x, op::SemiringObj* sring);
	pyDenseParVecObj2 SpMV(const pyDenseParVecObj2& x, op::SemiringObj* sring);
	pyDenseParVecObj1 SpMV(const pyDenseParVecObj1& x, op::SemiringObj* sring);

	void SpMV_inplace(pySpParVec&     x, op::SemiringObj* sring);
	void SpMV_inplace(pySpParVecObj2& x, op::SemiringObj* sring);
	void SpMV_inplace(pySpParVecObj1& x, op::SemiringObj* sring);
	void SpMV_inplace(pyDenseParVec&     x, op::SemiringObj* sring);
	void SpMV_inplace(pyDenseParVecObj2& x, op::SemiringObj* sring);
	void SpMV_inplace(pyDenseParVecObj1& x, op::SemiringObj* sring);

	void Square(op::SemiringObj* sring);
	pySpParMat     SpGEMM(pySpParMat     &other, op::SemiringObj* sring);
	pySpParMatBool SpGEMM(pySpParMatBool &other, op::SemiringObj* sring);
	pySpParMatObj2 SpGEMM(pySpParMatObj2 &other, op::SemiringObj* sring);
	pySpParMatObj1 SpGEMM(pySpParMatObj1 &other, op::SemiringObj* sring);

public:
	static int Column() { return ::Column; }
	static int Row() { return ::Row; }
};

pySpParMatObj2 EWiseApply(const pySpParMatObj2& A, const pySpParMat&     B, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, const Obj2& ANull, double BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParMatObj2 EWiseApply(const pySpParMatObj2& A, const pySpParMatBool& B, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, const Obj2& ANull, bool   BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParMatObj2 EWiseApply(const pySpParMatObj2& A, const pySpParMatObj2& B, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, const Obj2& ANull, const Obj2& BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParMatObj2 EWiseApply(const pySpParMatObj2& A, const pySpParMatObj1& B, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, const Obj2& ANull, const Obj1& BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);


class pySpParVec {
public:
	pySpParVec(int64_t length);
	
	pyDenseParVec dense() const;

public:
	int64_t getnee() const;
	int64_t __len__() const;
	int64_t len() const;

	pySpParVec copy();

public:	
	int64_t intersectSize(const pySpParVec& other);
	
	void printall();
	
public:	
	void load(const char* filename);
	void save(const char* filename);

public:
	// The functions commented out here presently do not exist in CombBLAS
	int64_t Count(op::UnaryFunction* op);
	int64_t Count(op::UnaryFunctionObj* op);
	//pySpParVec Find(op::UnaryFunction* op);
	//pyDenseParVec FindInds(op::UnaryFunction* op);
	void Apply(op::UnaryFunction* op);
	void Apply(op::UnaryFunctionObj* op);
	void ApplyInd(op::BinaryFunctionObj* op);
	//void ApplyMasked(op::UnaryFunction* op, const pySpParVec& mask);

	pyDenseParVec SubsRef(const pyDenseParVec& ri);
	
	double Reduce(op::BinaryFunction* f, op::UnaryFunction* uf = NULL);
	double Reduce(op::BinaryFunctionObj* f, op::UnaryFunctionObj* uf, double init);
	
	pySpParVec Sort(); // Does an in-place sort and returns the permutation used in the sort.
	pyDenseParVec TopK(int64_t k); // Returns a vector of the k largest elements.
	
	void setNumToInd();

public:
	static pySpParVec zeros(int64_t howmany);
	static pySpParVec range(int64_t howmany, int64_t start);
	
public:
	// Functions from PyCombBLAS
	void __delitem__(const pyDenseParVec& key);
	void __delitem__(int64_t key);
	
	double __getitem__(int64_t key);
	double __getitem__(double  key);
	pyDenseParVec __getitem__(const pyDenseParVec& key);
	
	void __setitem__(int64_t key, double value);
	void __setitem__(double  key, double value);
	void __setitem__(const pyDenseParVec& key, const pyDenseParVec& value);
	//void __setitem__(const pyDenseParVec& key, int64_t value);
	void __setitem__(const char* key, double value);	
	
	char* __repr__();
};

pySpParVec EWiseApply(const pySpParVec& a, const pySpParVecObj1& b, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, double ANull, Obj1 BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVec EWiseApply(const pySpParVec& a, const pySpParVecObj2& b, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, double ANull, Obj2 BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVec EWiseApply(const pySpParVec& a, const pySpParVec&     b, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, double ANull, double BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVec EWiseApply(const pySpParVec& a, const pySpParVecObj1& b, op::BinaryPredicateObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, double ANull, Obj1 BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVec EWiseApply(const pySpParVec& a, const pySpParVecObj2& b, op::BinaryPredicateObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, double ANull, Obj2 BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVec EWiseApply(const pySpParVec& a, const pySpParVec&     b, op::BinaryPredicateObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, double ANull, double BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);

/////////// with Dense
pySpParVec EWiseApply(const pySpParVec& a, const pyDenseParVec& b, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, double ANull, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVec EWiseApply(const pySpParVec& a, const pyDenseParVecObj1& b, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, double ANull, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVec EWiseApply(const pySpParVec& a, const pyDenseParVecObj2& b, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, double ANull, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVec EWiseApply(const pySpParVec& a, const pyDenseParVec& b, op::BinaryPredicateObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, double ANull, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVec EWiseApply(const pySpParVec& a, const pyDenseParVecObj1& b, op::BinaryPredicateObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, double ANull, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVec EWiseApply(const pySpParVec& a, const pyDenseParVecObj2& b, op::BinaryPredicateObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, double ANull, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);

//      EWiseMult has 2 flavors:
//      - if Exclude is false, will do element-wise multiplication
//      - if Exclude is true, will remove from the result vector all elements
//          whose corresponding element of the second vector is "nonzero"
//          (i.e., not equal to the sparse vector's identity value)  '

//pySpParVec EWiseMult(const pySpParVec& a, const pySpParVec& b, bool exclude);
pySpParVec EWiseMult(const pySpParVec& a, const pyDenseParVec& b, bool exclude, double zero);
void EWiseMult_inplacefirst(pySpParVec& a, const pyDenseParVec& b, bool exclude, double zero);



class pySpParVecObj1 {
public:
	pySpParVecObj1(int64_t length);
	
	pyDenseParVecObj1 dense() const;

public:
	int64_t getnee() const;
	int64_t __len__() const;
	int64_t len() const;

	pySpParVecObj1 copy();

public:	
	bool any() const; // any nonzeros
	bool all() const; // all nonzeros
	
	int64_t intersectSize(const pySpParVecObj1& other);
	
	void printall();
	
public:	
	void load(const char* filename);
	void save(const char* filename);

public:
	// The functions commented out here presently do not exist in CombBLAS
	int64_t Count(op::UnaryPredicateObj* op);
	//pySpParVecObj1 Find(op::UnaryFunctionObj* op);
	//pyDenseParVec FindInds(op::UnaryFunctionObj* op);
	void Apply(op::UnaryFunctionObj* op);
	void ApplyInd(op::BinaryFunctionObj* op);
	//void ApplyMasked(op::UnaryFunctionObj* op, const pySpParVecObj1& mask);

	pyDenseParVecObj1 SubsRef(const pyDenseParVec& ri);
	
	Obj1 Reduce(op::BinaryFunctionObj* f, op::UnaryFunctionObj* uf, Obj1 *init);
	double Reduce(op::BinaryFunctionObj* f, op::UnaryFunctionObj* uf, double init);
	
	pySpParVec Sort(); // Does an in-place sort and returns the permutation used in the sort.
	pyDenseParVecObj1 TopK(int64_t k); // Returns a vector of the k largest elements.
	

public:
	//static pySpParVecObj1 zeros(int64_t howmany);
	//static pySpParVecObj1 range(int64_t howmany, int64_t start);
	
public:
	//void __delitem__(const pyDenseParVec& key);
	void __delitem__(int64_t key);
	
	Obj1 __getitem__(int64_t key);
	Obj1 __getitem__(double key);
	pyDenseParVecObj1 __getitem__(const pyDenseParVec& key);
	
	void __setitem__(int64_t key, const Obj1 *value);
	void __setitem__(double key, const Obj1 *value);
	//void __setitem__(const pyDenseParVec& key, const pyDenseParVecObj1& value);
	//void __setitem__(const pyDenseParVec& key, int64_t value);
	void __setitem__(const char* key, const Obj1 *value);	
	
	char* __repr__();
};

pySpParVecObj1 EWiseApply(const pySpParVecObj1& a, const pySpParVecObj1& b, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, Obj1 ANull, Obj1 BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVecObj1 EWiseApply(const pySpParVecObj1& a, const pySpParVecObj2& b, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, Obj1 ANull, Obj2 BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVecObj1 EWiseApply(const pySpParVecObj1& a, const pySpParVec&     b, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, Obj1 ANull, double BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVec EWiseApply(const pySpParVecObj1& a, const pySpParVecObj1& b, op::BinaryPredicateObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, Obj1 ANull, Obj1 BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVec EWiseApply(const pySpParVecObj1& a, const pySpParVecObj2& b, op::BinaryPredicateObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, Obj1 ANull, Obj2 BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVec EWiseApply(const pySpParVecObj1& a, const pySpParVec&     b, op::BinaryPredicateObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, Obj1 ANull, double BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);

/////////// with Dense

pySpParVecObj1 EWiseApply(const pySpParVecObj1& a, const pyDenseParVec& b, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, Obj1 ANull, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVecObj1 EWiseApply(const pySpParVecObj1& a, const pyDenseParVecObj1& b, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, Obj1 ANull, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVecObj1 EWiseApply(const pySpParVecObj1& a, const pyDenseParVecObj2& b, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, Obj1 ANull, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVec EWiseApply(const pySpParVecObj1& a, const pyDenseParVec& b, op::BinaryPredicateObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, Obj1 ANull, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVec EWiseApply(const pySpParVecObj1& a, const pyDenseParVecObj1& b, op::BinaryPredicateObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, Obj1 ANull, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVec EWiseApply(const pySpParVecObj1& a, const pyDenseParVecObj2& b, op::BinaryPredicateObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, Obj1 ANull, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);

//      EWiseMult has 2 flavors:
//      - if Exclude is false, will do element-wise multiplication
//      - if Exclude is true, will remove from the result vector all elements
//          whose corresponding element of the second vector is "nonzero"
//          (i.e., not equal to the sparse vector's identity value)  '

//pySpParVecObj1 EWiseMult(const pySpParVecObj1& a, const pyDenseParVec& b, bool exclude, Obj1 zero);
//void EWiseMult_inplacefirst(pySpParVecObj1& a, const pyDenseParVec& b, bool exclude, Obj1 zero);



class pySpParVecObj2 {
public:
	pySpParVecObj2(int64_t length);
	
	pyDenseParVecObj2 dense() const;

public:
	int64_t getnee() const;
	int64_t __len__() const;
	int64_t len() const;

	pySpParVecObj2 copy();

public:	
	bool any() const; // any nonzeros
	bool all() const; // all nonzeros
	
	int64_t intersectSize(const pySpParVecObj2& other);
	
	void printall();
	
public:	
	void load(const char* filename);
	void save(const char* filename);

public:
	// The functions commented out here presently do not exist in CombBLAS
	int64_t Count(op::UnaryPredicateObj* op);
	//pySpParVecObj2 Find(op::UnaryFunctionObj* op);
	//pyDenseParVec FindInds(op::UnaryFunctionObj* op);
	void Apply(op::UnaryFunctionObj* op);
	void ApplyInd(op::BinaryFunctionObj* op);
	//void ApplyMasked(op::UnaryFunctionObj* op, const pySpParVecObj2& mask);

	pyDenseParVecObj2 SubsRef(const pyDenseParVec& ri);
	
	Obj2 Reduce(op::BinaryFunctionObj* f, op::UnaryFunctionObj* uf, Obj2 *init);
	double Reduce(op::BinaryFunctionObj* f, op::UnaryFunctionObj* uf, double init);
	
	pySpParVec Sort(); // Does an in-place sort and returns the permutation used in the sort.
	pyDenseParVecObj2 TopK(int64_t k); // Returns a vector of the k largest elements.
	

public:
	//static pySpParVecObj2 zeros(int64_t howmany);
	//static pySpParVecObj2 range(int64_t howmany, int64_t start);
	
public:
	//void __delitem__(const pyDenseParVec& key);
	void __delitem__(int64_t key);
	
	Obj2 __getitem__(int64_t key);
	Obj2 __getitem__(double key);
	pyDenseParVecObj2 __getitem__(const pyDenseParVec& key);
	
	void __setitem__(int64_t key, const Obj2 *value);
	void __setitem__(double key, const Obj2 *value);
	//void __setitem__(const pyDenseParVec& key, const pyDenseParVecObj2& value);
	//void __setitem__(const pyDenseParVec& key, int64_t value);
	void __setitem__(const char* key, const Obj2 *value);	
	
	char* __repr__();
};

pySpParVecObj2 EWiseApply(const pySpParVecObj2& a, const pySpParVecObj2& b, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, Obj2 ANull, Obj2 BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVecObj2 EWiseApply(const pySpParVecObj2& a, const pySpParVecObj1& b, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, Obj2 ANull, Obj1 BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVecObj2 EWiseApply(const pySpParVecObj2& a, const pySpParVec&     b, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, Obj2 ANull, double BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVec EWiseApply(const pySpParVecObj2& a, const pySpParVecObj2& b, op::BinaryPredicateObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, Obj2 ANull, Obj2 BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVec EWiseApply(const pySpParVecObj2& a, const pySpParVecObj1& b, op::BinaryPredicateObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, Obj2 ANull, Obj1 BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVec EWiseApply(const pySpParVecObj2& a, const pySpParVec&     b, op::BinaryPredicateObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, bool allowBNulls, Obj2 ANull, double BNull, bool allowIntersect, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);

/////////// with Dense

pySpParVecObj2 EWiseApply(const pySpParVecObj2& a, const pyDenseParVec& b, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, Obj2 ANull, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVecObj2 EWiseApply(const pySpParVecObj2& a, const pyDenseParVecObj2& b, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, Obj2 ANull, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVecObj2 EWiseApply(const pySpParVecObj2& a, const pyDenseParVecObj1& b, op::BinaryFunctionObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, Obj2 ANull, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVec EWiseApply(const pySpParVecObj2& a, const pyDenseParVec& b, op::BinaryPredicateObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, Obj2 ANull, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVec EWiseApply(const pySpParVecObj2& a, const pyDenseParVecObj2& b, op::BinaryPredicateObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, Obj2 ANull, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
pySpParVec EWiseApply(const pySpParVecObj2& a, const pyDenseParVecObj1& b, op::BinaryPredicateObj* op, op::BinaryPredicateObj* doOp, bool allowANulls, Obj2 ANull, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);

//      EWiseMult has 2 flavors:
//      - if Exclude is false, will do element-wise multiplication
//      - if Exclude is true, will remove from the result vector all elements
//          whose corresponding element of the second vector is "nonzero"
//          (i.e., not equal to the sparse vector's identity value)  '

//pySpParVecObj2 EWiseMult(const pySpParVecObj2& a, const pyDenseParVec& b, bool exclude, Obj2 zero);
//void EWiseMult_inplacefirst(pySpParVecObj2& a, const pyDenseParVec& b, bool exclude, Obj2 zero);



class pyDenseParVec {
public:
	pyDenseParVec(int64_t size, double init = 0);
	
	pySpParVec sparse() const;
	pySpParVec sparse(double zero) const;
	
public:
	int64_t len() const;
	int64_t __len__() const;
	
	pyDenseParVec copy();
	
	pyDenseParVec SubsRef(const pyDenseParVec& ri);

	void RandPerm(); // Randomly permutes the vector
	pyDenseParVec Sort(); // Does an in-place sort and returns the permutation used in the sort.
	pyDenseParVec TopK(int64_t k); // Returns a vector of the k largest elements.

	void printall();
	void SelectCandidates(double nvert, bool deterministic); // Graph500 candidate selection. Very specialized routine, not meant for general consumption. It exists purely to use the exact same code that CombBLAS runs use to remove run differences due to RNG.
	
public:
	
	int64_t getnee() const;
	
public:	
	void load(const char* filename);
	void save(const char* filename);
	
public:
	int64_t Count(op::UnaryFunction* op);
	int64_t Count(op::UnaryPredicateObj* op);
	double Reduce(op::BinaryFunction* f, op::UnaryFunction* uf = NULL);
	double Reduce(op::BinaryFunctionObj* f, op::UnaryFunctionObj* uf, double init);
	pySpParVec Find(op::UnaryFunction* op);
	pySpParVec Find(op::UnaryPredicateObj* op);
	pySpParVec __getitem__(op::UnaryFunction* op);
	pyDenseParVec FindInds(op::UnaryFunction* op);
	pyDenseParVec FindInds(op::UnaryPredicateObj* op);
	void Apply(op::UnaryFunction* op);
	void Apply(op::UnaryFunctionObj* op);
	void ApplyInd(op::BinaryFunctionObj* op);
	void ApplyMasked(op::UnaryFunction* op, const pySpParVec& mask);
	void ApplyMasked(op::UnaryFunctionObj* op, const pySpParVec& mask);

	void EWiseApply(const pyDenseParVecObj1& other, op::BinaryFunctionObj *op, op::BinaryPredicateObj *doOp, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pyDenseParVecObj2& other, op::BinaryFunctionObj *op, op::BinaryPredicateObj *doOp, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pyDenseParVec&     other, op::BinaryFunctionObj *op, op::BinaryPredicateObj *doOp, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pySpParVecObj1& other, op::BinaryFunctionObj *op, op::BinaryPredicateObj *doOp, bool doNulls, Obj1 nullValue, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pySpParVecObj2& other, op::BinaryFunctionObj *op, op::BinaryPredicateObj *doOp, bool doNulls, Obj2 nullValue, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pySpParVec&     other, op::BinaryFunctionObj *op, op::BinaryPredicateObj *doOp, bool doNulls, double nullValue, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);

	// predicate versions.
	void EWiseApply(const pyDenseParVecObj1& other, op::BinaryPredicateObj *op, op::BinaryPredicateObj *doOp, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pyDenseParVecObj2& other, op::BinaryPredicateObj *op, op::BinaryPredicateObj *doOp, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pyDenseParVec&     other, op::BinaryPredicateObj *op, op::BinaryPredicateObj *doOp, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pySpParVecObj1& other, op::BinaryPredicateObj *op, op::BinaryPredicateObj *doOp, bool doNulls, Obj1 nullValue, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pySpParVecObj2& other, op::BinaryPredicateObj *op, op::BinaryPredicateObj *doOp, bool doNulls, Obj2 nullValue, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pySpParVec&     other, op::BinaryPredicateObj *op, op::BinaryPredicateObj *doOp, bool doNulls, double nullValue, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);

public:
	static pyDenseParVec range(int64_t howmany, int64_t start);
	
public:
	double __getitem__(int64_t key);
	double __getitem__(double  key);
	pyDenseParVec __getitem__(const pyDenseParVec& key);

	void __setitem__(int64_t key, double value);
	void __setitem__(double  key, double value);
	void __setitem__(const pySpParVec& key, const pySpParVec& value);
	void __setitem__(const pySpParVec& key, double value);
};


class pyDenseParVecObj1 {
public:
	pyDenseParVecObj1(int64_t size, Obj1 init = Obj1());
	
	pySpParVecObj1 sparse(op::UnaryPredicateObj* keep = NULL) const;
	//pySpParVecObj1 sparse(double zero) const;
	
public:
	int64_t len() const;
	int64_t __len__() const;
	
	pyDenseParVecObj1 copy();
	
	pyDenseParVecObj1 SubsRef(const pyDenseParVec& ri);

	void RandPerm(); // Randomly permutes the vector
	pyDenseParVec Sort(); // Does an in-place sort and returns the permutation used in the sort.
	pyDenseParVecObj1 TopK(int64_t k); // Returns a vector of the k largest elements.

	void printall();
	
public:
	
	int64_t getnee() const;
	
public:	
	void load(const char* filename);
	void save(const char* filename);
	
public:
	int64_t Count(op::UnaryPredicateObj* op);
	Obj1 Reduce(op::BinaryFunctionObj* f, op::UnaryFunctionObj* uf, Obj1 *init);
	double Reduce(op::BinaryFunctionObj* f, op::UnaryFunctionObj* uf, double init);
	pySpParVecObj1 Find(op::UnaryPredicateObj* op);
	pySpParVecObj1 __getitem__(op::UnaryPredicateObj* op);
	pyDenseParVec FindInds(op::UnaryPredicateObj* op);
	void Apply(op::UnaryFunctionObj* op);
	void ApplyMasked(op::UnaryFunctionObj* op, const pySpParVec& mask);
	void ApplyInd(op::BinaryFunctionObj* op);
	void EWiseApply(const pyDenseParVecObj1& other, op::BinaryFunctionObj *op, op::BinaryPredicateObj *doOp, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pyDenseParVecObj2& other, op::BinaryFunctionObj *op, op::BinaryPredicateObj *doOp, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pyDenseParVec&     other, op::BinaryFunctionObj *op, op::BinaryPredicateObj *doOp, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pySpParVecObj1& other, op::BinaryFunctionObj *op, op::BinaryPredicateObj *doOp, bool doNulls, Obj1 nullValue, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pySpParVecObj2& other, op::BinaryFunctionObj *op, op::BinaryPredicateObj *doOp, bool doNulls, Obj2 nullValue, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pySpParVec&     other, op::BinaryFunctionObj *op, op::BinaryPredicateObj *doOp, bool doNulls, double nullValue, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);

	/* predicate versions. NEEDS to return new pyDenseParVec
	void EWiseApply(const pyDenseParVecObj1& other, op::BinaryPredicateObj *op, op::BinaryPredicateObj *doOp, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pyDenseParVecObj2& other, op::BinaryPredicateObj *op, op::BinaryPredicateObj *doOp, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pyDenseParVec&     other, op::BinaryPredicateObj *op, op::BinaryPredicateObj *doOp, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pySpParVecObj1& other, op::BinaryPredicateObj *op, op::BinaryPredicateObj *doOp, bool doNulls, Obj1 *nullValue, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pySpParVecObj2& other, op::BinaryPredicateObj *op, op::BinaryPredicateObj *doOp, bool doNulls, Obj2 *nullValue, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pySpParVec&     other, op::BinaryPredicateObj *op, op::BinaryPredicateObj *doOp, bool doNulls, double nullValue, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	*/
public:
	//static pyDenseParVecObj1 range(int64_t howmany, int64_t start);
	
public:
	// Functions from PyCombBLAS
	
	Obj1 __getitem__(int64_t key);
	pyDenseParVecObj1 __getitem__(const pyDenseParVec& key);

	void __setitem__(int64_t key, Obj1 * value);
	//void __setitem__(const pySpParVec& key, const pySpParVecObj1& value);
	void __setitem__(const pySpParVec& key, Obj1 * value);
	
	char* __repr__();
};



class pyDenseParVecObj2 {
public:
	pyDenseParVecObj2(int64_t size, Obj2 init = Obj2());
	
	pySpParVecObj2 sparse(op::UnaryPredicateObj* keep = NULL) const;
	//pySpParVecObj2 sparse(double zero) const;
	
public:
	int64_t len() const;
	int64_t __len__() const;
	
	pyDenseParVecObj2 copy();
	
	pyDenseParVecObj2 SubsRef(const pyDenseParVec& ri);

	void RandPerm(); // Randomly permutes the vector
	pyDenseParVec Sort(); // Does an in-place sort and returns the permutation used in the sort.
	pyDenseParVecObj2 TopK(int64_t k); // Returns a vector of the k largest elements.

	void printall();
	
public:
	
	int64_t getnee() const;
	
public:	
	void load(const char* filename);
	void save(const char* filename);
	
public:
	int64_t Count(op::UnaryPredicateObj* op);
	Obj2 Reduce(op::BinaryFunctionObj* f, op::UnaryFunctionObj* uf, Obj2 *init);
	double Reduce(op::BinaryFunctionObj* f, op::UnaryFunctionObj* uf, double init);
	pySpParVecObj2 Find(op::UnaryPredicateObj* op);
	pySpParVecObj2 __getitem__(op::UnaryPredicateObj* op);
	pyDenseParVec FindInds(op::UnaryPredicateObj* op);
	void Apply(op::UnaryFunctionObj* op);
	void ApplyMasked(op::UnaryFunctionObj* op, const pySpParVec& mask);
	void ApplyInd(op::BinaryFunctionObj* op);
	void EWiseApply(const pyDenseParVecObj2& other, op::BinaryFunctionObj *op, op::BinaryPredicateObj *doOp, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pyDenseParVecObj1& other, op::BinaryFunctionObj *op, op::BinaryPredicateObj *doOp, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pyDenseParVec&     other, op::BinaryFunctionObj *op, op::BinaryPredicateObj *doOp, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pySpParVecObj2& other, op::BinaryFunctionObj *op, op::BinaryPredicateObj *doOp, bool doNulls, Obj2 nullValue, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pySpParVecObj1& other, op::BinaryFunctionObj *op, op::BinaryPredicateObj *doOp, bool doNulls, Obj1 nullValue, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pySpParVec&     other, op::BinaryFunctionObj *op, op::BinaryPredicateObj *doOp, bool doNulls, double nullValue, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);

	/* predicate versions. NEEDS to return new pyDenseParVec
	void EWiseApply(const pyDenseParVecObj2& other, op::BinaryPredicateObj *op, op::BinaryPredicateObj *doOp, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pyDenseParVecObj1& other, op::BinaryPredicateObj *op, op::BinaryPredicateObj *doOp, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pyDenseParVec&     other, op::BinaryPredicateObj *op, op::BinaryPredicateObj *doOp, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pySpParVecObj2& other, op::BinaryPredicateObj *op, op::BinaryPredicateObj *doOp, bool doNulls, Obj2 *nullValue, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pySpParVecObj1& other, op::BinaryPredicateObj *op, op::BinaryPredicateObj *doOp, bool doNulls, Obj1 *nullValue, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	void EWiseApply(const pySpParVec&     other, op::BinaryPredicateObj *op, op::BinaryPredicateObj *doOp, bool doNulls, double nullValue, op::UnaryPredicateObj* AFilterPred, op::UnaryPredicateObj* BFilterPred);
	*/
public:
	//static pyDenseParVecObj2 range(int64_t howmany, int64_t start);
	
public:
	// Functions from PyCombBLAS
	
	Obj2 __getitem__(int64_t key);
	pyDenseParVecObj2 __getitem__(const pyDenseParVec& key);

	void __setitem__(int64_t key, Obj2 * value);
	//void __setitem__(const pySpParVec& key, const pySpParVecObj2& value);
	void __setitem__(const pySpParVec& key, Obj2 * value);
	
	char* __repr__();
};


namespace op {

class UnaryFunction {

	protected:
	UnaryFunction(): op(NULL) {}
	public:
	~UnaryFunction() { /*delete op; op = NULL;*/ }
	
	doubleint operator()(const doubleint x) const
	{
		return (*op)(x);
	}
};

UnaryFunction set(double val);
UnaryFunction identity();
UnaryFunction safemultinv();
UnaryFunction abs();
UnaryFunction negate();
UnaryFunction bitwise_not();
UnaryFunction logical_not();
UnaryFunction totality();
UnaryFunction ifthenelse(UnaryFunction& predicate, UnaryFunction& runTrue, UnaryFunction& runFalse);

UnaryFunction unary(PyObject *pyfunc);

class BinaryFunction {
	protected:
	BinaryFunction(): op(NULL), commutable(false), associative(false) {}
	public:
	~BinaryFunction() { /*delete op; op = NULL;*/ }
	
	bool commutable;
	bool associative;
	
	doubleint operator()(const doubleint& x, const doubleint& y) const
	{
		return (*op)(x, y);
	}

};

BinaryFunction plus();
BinaryFunction minus();
BinaryFunction multiplies();
BinaryFunction divides();
BinaryFunction modulus();
BinaryFunction fmod();
BinaryFunction pow();

BinaryFunction max();
BinaryFunction min();

BinaryFunction bitwise_and();
BinaryFunction bitwise_or();
BinaryFunction bitwise_xor();
BinaryFunction logical_and();
BinaryFunction logical_or();
BinaryFunction logical_xor();

BinaryFunction equal_to();
BinaryFunction not_equal_to();
BinaryFunction greater();
BinaryFunction less();
BinaryFunction greater_equal();
BinaryFunction less_equal();

BinaryFunction binary(PyObject *pyfunc);
BinaryFunction* binaryPtr(PyObject *pyfunc);

// Glue functions

UnaryFunction bind1st(BinaryFunction& op, double val);
UnaryFunction bind2nd(BinaryFunction& op, double val);
UnaryFunction compose1(UnaryFunction& f, UnaryFunction& g); // h(x) is the same as f(g(x))
UnaryFunction compose2(BinaryFunction& f, UnaryFunction& g1, UnaryFunction& g2); // h(x) is the same as f(g1(x), g2(x))
UnaryFunction not1(UnaryFunction& f);
BinaryFunction not2(BinaryFunction& f);



// Semiring class removed in favor of SemiringObj

} // namespace op



class Obj1 {
public:
////////////////////////////////////////////////////
////////////////////////////////////////////////////
///// USER CHANGEABLE CODE BEGIN

	double weight;
	int category;
	
	////////////////
	// for Python-definable objects
	uint8_t data[64];
	
	static size_t capacity() {
		return sizeof(uint8_t)*64;
	}

	void* getDataPtr() {
		return data;
	}
	
	// void* gets wrapped by SWIG into something that doesn't talk with ctypes,
	// while a regular integer can be cast into a ctypes pointer.
	unsigned long long getDataPtrLong() {
		return reinterpret_cast<unsigned long long>(data);
	}
	////////////////

	// Note: It's important that this default constructor creates a "zero" element. Some operations
	// (eg. Reduce) need a starting element, and this constructor is used to create one. If the
	// "zero" rule is not followed then you may get different results on different numbers of
	// processors.
	Obj1(): weight(0), category(0) {}
	Obj1(const Obj1& other): weight(other.weight), category(other.category) { memcpy(data, other.data, capacity()); }

	char *__repr__() const {
		static char temp[256];
		sprintf(temp,"[ %lf, %d ]", weight,category);
		return &temp[0];
	}
	
	bool __eq__(const Obj1& other) const {
		return weight == other.weight && category == other.category;
	}

	bool __ne__(const Obj1& other) const {
		return !(__eq__(other));
	}

	// For sorting
	bool __lt__(const Obj1& other) const {
		return weight < other.weight;
	}

	// for filtering matrices.
	//bool hasPassedFilter;
};


class Obj2 {
public:
////////////////////////////////////////////////////
////////////////////////////////////////////////////
///// USER CHANGEABLE CODE BEGIN

	bool follower;		// default constructor sets all to zero
	long latest;		// not assigned if no retweets happened
	short count;		

	// Note: It's important that this default constructor creates a "zero" element. Some operations
	// (eg. Reduce) need a starting element, and this constructor is used to create one. If the
	// "zero" rule is not followed then you may get different results on different numbers of
	// processors.
	Obj2(): follower(0), latest(0), count(0) {}
	Obj2(const Obj2& other): follower(other.follower), latest(other.latest), count(other.count) {}

	char *__repr__() const {
		static char temp[256];
		if (count == 0)
		{
			sprintf(temp,"[ %d, %d ]", follower, count);
		}
		else
		{
#ifndef _MSC_VER
			struct tm timeinfo;
			gmtime_r((time_t*)&latest, &timeinfo);
			
			char s[256];
			sprintf(s, "%d-%d-%d %d:%d:%d", timeinfo.tm_year+1900,
											timeinfo.tm_mon+1,
											timeinfo.tm_mday,
											timeinfo.tm_hour,
											timeinfo.tm_min,
											timeinfo.tm_sec);
			sprintf(temp,"[ %d, %d, %s ]", follower, count, s);
#else
			sprintf(temp,"[Unsup. on Win.]");
#endif
			}
		return &temp[0];
	}
	
	bool __eq__(const Obj2& other) const {
		return follower == other.follower && count == other.count && latest == other.latest;
	}

	bool __ne__(const Obj2& other) const {
		return !(operator==(other));
	}

	// For sorting
	bool __lt__(const Obj2& other) const {
		return count < other.count;
	}

	// for filtering matrices.
	//bool hasPassedFilter;	
};

namespace op {

class CallError {};


class UnaryPredicateObj {
	public:
	PyObject* getCallback() const { return worker.getCallback(); }
	void setCallback(PyObject *pyfunc) { worker.setCallback(pyfunc); }

	bool operator()(const Obj2& x) const { return worker(x); }
	bool operator()(const Obj1& x) const { return worker(x); }
	bool operator()(const double& x) const { return worker(x); }

	//protected:
	UnaryPredicateObj() {
	}

	public:
	~UnaryPredicateObj() { }
};

class UnaryFunctionObj {
	public:
	PyObject* getCallback() const { return worker.getCallback(); }
	void setCallback(PyObject *pyfunc) { worker.setCallback(pyfunc); }

	Obj2 operator()(const Obj2& x) const { return worker(x); }
	Obj1 operator()(const Obj1& x) const { return worker(x); }
	double operator()(const double& x) const { return worker(x); }
	
    //	protected:
	UnaryFunctionObj() {
	}

	public:
	~UnaryFunctionObj() { }
};


UnaryFunctionObj unaryObj(PyObject *pyfunc);
UnaryPredicateObj unaryObjPred(PyObject *pyfunc);

class BinaryFunctionObj {
//	protected:
	BinaryFunctionObj(): commutable(false), associative(false) {}
	public:
	~BinaryFunctionObj() {  }
	
	PyObject* getCallback() const { return worker.getCallback(); }
	void setCallback(PyObject *pyfunc) { worker.setCallback(pyfunc); }
	
	bool commutable;
	bool associative;
	
	Obj1 operator()(const Obj1& x, const Obj1& y) const { return worker(x, y); }
	Obj2 operator()(const Obj2& x, const Obj2& y) const { return worker(x, y); }
	Obj1 operator()(const Obj1& x, const Obj2& y) const { return worker(x, y); }
	Obj2 operator()(const Obj2& x, const Obj1& y) const { return worker(x, y); }

	Obj1 operator()(const Obj1& x, const double& y) const { return worker(x, y); }
	Obj2 operator()(const Obj2& x, const double& y) const { return worker(x, y); }
	double operator()(const double& x, const Obj1& y) const { return worker(x, y); }
	double operator()(const double& x, const Obj2& y) const { return worker(x, y); }

	double operator()(const double& x, const double& y) const { return worker(x, y); }


	// These are used by the semiring ops. They do the same thing as the operator() above,
	// but their return type matches the 2nd argument instead of the 1st.
	Obj1 rettype2nd_call(const Obj1& x, const Obj1& y) const { return worker.rettype2nd_call(x, y); }
	Obj2 rettype2nd_call(const Obj2& x, const Obj2& y) const { return worker.rettype2nd_call(x, y); }
	Obj1 rettype2nd_call(const Obj2& x, const Obj1& y) const { return worker.rettype2nd_call(x, y); }
	Obj2 rettype2nd_call(const Obj1& x, const Obj2& y) const { return worker.rettype2nd_call(x, y); }

	double rettype2nd_call(const Obj1& x, const double& y) const { return worker.rettype2nd_call(x, y); }
	double rettype2nd_call(const Obj2& x, const double& y) const { return worker.rettype2nd_call(x, y); }
	Obj1 rettype2nd_call(const double& x, const Obj1& y) const { return worker.rettype2nd_call(x, y); }
	Obj2 rettype2nd_call(const double& x, const Obj2& y) const { return worker.rettype2nd_call(x, y); }

	double rettype2nd_call(const double& x, const double& y) const { return worker.rettype2nd_call(x, y); }

};

class BinaryPredicateObj {
	public:
	PyObject* getCallback() const { return worker.getCallback(); }
	void setCallback(PyObject *pyfunc) { worker.setCallback(pyfunc); }

	bool operator()(const Obj1& x, const Obj1& y) const { return worker(x, y); }
	bool operator()(const Obj1& x, const Obj2& y) const { return worker(x, y); }
	bool operator()(const Obj2& x, const Obj2& y) const { return worker(x, y); }
	bool operator()(const Obj2& x, const Obj1& y) const { return worker(x, y); }

	bool operator()(const Obj1& x, const double& y) const { return worker(x, y); }
	bool operator()(const Obj2& x, const double& y) const { return worker(x, y); }
	bool operator()(const double& x, const Obj2& y) const { return worker(x, y); }
	bool operator()(const double& x, const Obj1& y) const { return worker(x, y); }

	bool operator()(const double& x, const double& y) const { return worker(x, y); }

	//protected:
	BinaryPredicateObj() {
	}

	public:
	~BinaryPredicateObj() { /*Py_XDECREF(callback);*/ }
};

BinaryFunctionObj binaryObj(PyObject *pyfunc, bool comm=false);
BinaryPredicateObj binaryObjPred(PyObject *pyfunc);
class SemiringObj {
	protected:
	SemiringObj(): type(NONE)/*, pyfunc_add(NULL), pyfunc_multiply(NULL)*/, binfunc_add(NULL), binfunc_mul(NULL), own_add_mul(true), left_filter(NULL), right_filter(NULL) {}
	public:
	SemiringObj(PyObject *add, PyObject *multiply, PyObject* left_filter_py = NULL, PyObject* right_filter_py = NULL);
	SemiringObj(BinaryFunctionObj *add, BinaryFunctionObj *multiply);
	~SemiringObj();
	
	void setFilters(PyObject* left_filter_py = NULL, PyObject* right_filter_py = NULL);
	
	PyObject* getAddCallback() const { return binfunc_add != NULL ? binfunc_add->getCallback() : NULL; }
	PyObject* getMulCallback() const { return binfunc_mul != NULL ? binfunc_mul->getCallback() : NULL; }
	
	MPI_Op mpi_op()
	{
		binfunc_add->getMPIOp();
		return *(BinaryFunctionObj_MPI_Interface::mpi_op());
	}
	
	//doubleint add(const doubleint & arg1, const doubleint & arg2);	
	//doubleint multiply(const doubleint & arg1, const doubleint & arg2);
	//void axpy(doubleint a, const doubleint & x, doubleint & y);

};
SemiringObj TimesPlusSemiringObj();
//SemiringObj MinPlusSemiringObj();
SemiringObj SecondMaxSemiringObj();
//SemiringObj SecondSecondSemiringObj();

} // namespace op


void finalize();
bool root();
void _broadcast(char *outMsg, char *inMsg);
void _barrier();
int _nprocs();
int _rank();
void prnt(const char* str);
double _random();

class NotFoundError {};

class EWiseArg
{
	public:
	EWiseArg(): dptr(NULL), sptr(NULL), type(SPARSE) {}
};

EWiseArg EWise_Index();
EWiseArg EWise_OnlyNZ(pySpParVec* v);
EWiseArg EWise_OnlyNZ(pyDenseParVec* v); // shouldn't be used, but here for completeness

/*
%typemap(in) char ** {
  // Check if is a list
  if (PyList_Check($input)) {
    int size = PyList_Size($input);
    int i = 0;
    $1 = (char **) malloc((size+1)*sizeof(char *));
    for (i = 0; i < size; i++) {
      PyObject *o = PyList_GetItem($input,i);
      if (PyString_Check(o))
	$1[i] = PyString_AsString(PyList_GetItem($input,i));
      else {
	PyErr_SetString(PyExc_TypeError,"list must contain strings");
	free($1);
	return NULL;
      }
    }
    $1[i] = 0;
  } else {
    PyErr_SetString(PyExc_TypeError,"not a list");
    return NULL;
  }
}

// This cleans up the char ** array we malloc'd before the function call
%typemap(freearg) char ** {
  free((char *) $1);
}*/

%typemap(in) (int argc, EWiseArgDescriptor* argv, PyObject *argList) {
	/* Check if is a list */
	if (PyList_Check($input)) {
		int size = PyList_Size($input);
		int i = 0;

		$1 = size;
		$2 = new EWiseArgDescriptor[size];
		$3 = $input;

		pyDenseParVec* dptr;
		pySpParVec* sptr;
		EWiseArg* argptr;
		for (i = 0; i < size; i++)
		{
			PyObject *o = PyList_GetItem($input,i);
			if (SWIG_IsOK(SWIG_ConvertPtr(o, (void**)&dptr, $descriptor(pyDenseParVec *), 0)))
			{
				$2[i].type = EWiseArgDescriptor::ITERATOR;
				$2[i].onlyNZ = false;
				$2[i].iter = new DenseVectorLocalIterator<int64_t, doubleint>(dptr->v);
			}
			else if (SWIG_IsOK(SWIG_ConvertPtr(o, (void**)&sptr, $descriptor(pySpParVec *), 0)))
			{
				$2[i].type = EWiseArgDescriptor::ITERATOR;
				$2[i].onlyNZ = false;
				$2[i].iter = new SparseVectorLocalIterator<int64_t, doubleint>(sptr->v);
			}
			else if (SWIG_IsOK(SWIG_ConvertPtr(o, (void**)&argptr, $descriptor(EWiseArg *), 0)))
			{
				switch (argptr->type)
				{
					case EWiseArg::GLOBAL_INDEX:
						$2[i].type = EWiseArgDescriptor::GLOBAL_INDEX;
						break;
					case EWiseArg::DENSE:
						$2[i].type = EWiseArgDescriptor::ITERATOR;
						$2[i].onlyNZ = false;
						$2[i].iter = new DenseVectorLocalIterator<int64_t, doubleint>(argptr->dptr->v);
						break;
					case EWiseArg::SPARSE:
						$2[i].type = EWiseArgDescriptor::ITERATOR;
						$2[i].onlyNZ = false;
						$2[i].iter = new SparseVectorLocalIterator<int64_t, doubleint>(argptr->sptr->v);
						break;
					case EWiseArg::SPARSE_NZ:
						$2[i].type = EWiseArgDescriptor::ITERATOR;
						$2[i].onlyNZ = true;
						$2[i].iter = new SparseVectorLocalIterator<int64_t, doubleint>(argptr->sptr->v);
						break;
					default:
						cout << "AAAHHH! What are you passing to EWise()?" << endl;
						break;
				}
			}
			else
			{
				// python object
				$2[i].type = EWiseArgDescriptor::PYTHON_OBJ;
			}
		}
		
	} else {
		PyErr_SetString(PyExc_TypeError,"not a list");
		return NULL;
	}
}

// This cleans up the char ** array we malloc'd before the function call
%typemap(freearg) (int argc, EWiseArgDescriptor* argv, PyObject *argList) {
	delete [] $2;
}


void EWise(PyObject *pyewisefunc, int argc, EWiseArgDescriptor* argv, PyObject *argList);
void Graph500VectorOps(pySpParVec& fringe_v, pyDenseParVec& parents_v);


// It is possible to have the generated python code also include some custom code.
// This may be a good place to add an atexit() to call MPI finalize.
// The problem is that MPI objects still likely exist at this point unless the user explicitly deleted them, which leads to ugly error messages.
%pythoncode %{
#import atexit
#atexit.register(finalize)
%}

%pythoncode %{
try:
	import ObjMethods

	ObjMethods.defUserCallbacks((Obj1,Obj2))
except ImportError:
	print "Failed to import ObjMethods!"
	print "----------------------------"
	print ""
%}
