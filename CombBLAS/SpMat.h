/****************************************************************/
/* Sequential and Parallel Sparse Matrix Multiplication Library */
/* version 2.3 --------------------------------------------------/
/* date: 01/18/2009 ---------------------------------------------/
/* author: Aydin Buluc (aydin@cs.ucsb.edu) ----------------------/
/****************************************************************/

#ifndef _SP_MAT_H
#define _SP_MAT_H

#include <iostream>
#include <vector>
#include <utility>
#include "SpDefs.h"
#include "promote.h"
#include "LocArr.h"

using namespace std;

// Forward declaration (required since a friend function returns a SpTuples object)
template <class IU, class NU>	
class SpTuples;


/**
 ** The abstract base class for all derived sequential sparse matrix classes
 ** Contains no data members, hence no copy constructor/assignment operator
 ** Uses static polymorphism through curiously recurring templates (CRTP)
 ** Template parameters: IT (index type), NT (numerical type), DER (derived class type)
 **/
template < class IT, class NT, class DER >
class SpMat
{
public:
	//! Standard destructor, copy ctor and assignment are generated by compiler, they all do nothing !
	//! Default constructor also exists, and does nothing more than creating Base<Derived>() and Derived() objects
	//! One has to call one of the overloaded create functions to get an nonempty object
	void Create(vector<IT> & essentials)
	{
		static_cast<DER*>(this)->CreateImpl(essentials);
	}
	
	SpMat< IT,NT,DER >  operator() (const vector<IT> & ri, const vector<IT> & ci) const;
	
	template <typename SR>
	void SpGEMM( SpMat< IT,NT,DER > & A, SpMat< IT,NT,DER > & B, bool isAT, bool isBT);

	Arr<IT,NT> GetArrays() const
	{
		return static_cast<const DER*>(this)->GetArrays();
	}	
		
	ofstream& put(ofstream& outfile) const;
	ifstream& get(ifstream& infile);
	
	IT getnrow() const { return static_cast<const DER*>(this)->getnrow(); }
	IT getncol() const { return static_cast<const DER*>(this)->getncol(); }
	IT getnnz() const  { return static_cast<const DER*>(this)->getnnz(); }

protected:

	template < typename UIT, typename UNT, typename UDER >
	friend ofstream& operator<< (ofstream& outfile, const SpMat< UIT,UNT,UDER > & s);	

	template < typename UIT, typename UNT, typename UDER >
	friend ifstream& operator>> (ifstream& infile, SpMat< UIT,UNT,UDER > & s);

	template<class IU, class NU1, class NU2, class SR>
	friend SpTuples< IU, typename promote_trait<NU1,NU2>::T_promote >
	MultiplyReturnTuples (const SpMat< IU, NU1, DER > & A, const SpMat< IU, NU2, DER > & B, bool isAT, bool isBT);

};

#include "SpMat.cpp"	
#endif

