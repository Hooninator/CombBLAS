-- Will be using pre-selected starting vertices for huge: [14472363, 13699402, 3890644, 14569240, 5705911, 394273, 7630462, 13303812, 754337, 9095300, 10736458, 15183577, 14039705]
--Reading network from /home/aydin/twitter/twitter_from06_to-12.induced.bin.remapped.bin.converted.balanced
Read in 64.351499s. Read 	16819398	 vertices and 	721043215	 edges.
--calculating degrees on original graph
Calculated in 61.178116s.

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
Created SEJITS filter for 	1246406400	% in	0.038982	s.
--Generating starting verts

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
Generated starting verts in 163.924782s.
--Doing BFS
12464064.000000	: iteration 1.0: start=14472363, BFS took 	4.787001	s, covered 	68745	 edges, discovered 	43019	 verts, TEPS incl. filtered edges=	12,586,004	, TEPS=	14,360	 
12464064.000000	: iteration 2.0: start=13699402, BFS took 	1.094048	s, covered 	68793	 edges, discovered 	43046	 verts, TEPS incl. filtered edges=	55,134,288	, TEPS=	62,879	 
12464064.000000	: iteration 3.0: start= 3890644, BFS took 	1.098124	s, covered 	68754	 edges, discovered 	43025	 verts, TEPS incl. filtered edges=	54,868,433	, TEPS=	62,610	 
12464064.000000	: iteration 4.0: start=14569240, BFS took 	1.085178	s, covered 	68745	 edges, discovered 	43019	 verts, TEPS incl. filtered edges=	55,520,126	, TEPS=	63,349	 
12464064.000000	: iteration 5.0: start= 5705911, BFS took 	1.129622	s, covered 	68751	 edges, discovered 	43022	 verts, TEPS incl. filtered edges=	53,336,646	, TEPS=	60,861	 
12464064.000000	: iteration 6.0: start=  394273, BFS took 	1.045954	s, covered 	68745	 edges, discovered 	43019	 verts, TEPS incl. filtered edges=	57,602,164	, TEPS=	65,724	 
12464064.000000	: iteration 7.0: start= 7630462, BFS took 	1.699736	s, covered 	68747	 edges, discovered 	43020	 verts, TEPS incl. filtered edges=	35,446,253	, TEPS=	40,445	 
12464064.000000	: iteration 8.0: start=13303812, BFS took 	1.489623	s, covered 	68899	 edges, discovered 	43142	 verts, TEPS incl. filtered edges=	40,474,497	, TEPS=	46,252	 
12464064.000000	: iteration 9.0: start=  754337, BFS took 	1.134991	s, covered 	68745	 edges, discovered 	43019	 verts, TEPS incl. filtered edges=	53,083,432	, TEPS=	60,568	 
12464064.000000	: iteration 10.0: start= 9095300, BFS took 	1.132850	s, covered 	68748	 edges, discovered 	43022	 verts, TEPS incl. filtered edges=	53,183,959	, TEPS=	60,685	 
12464064.000000	: iteration 11.0: start=10736458, BFS took 	1.174109	s, covered 	68757	 edges, discovered 	43029	 verts, TEPS incl. filtered edges=	51,326,186	, TEPS=	58,561	 
12464064.000000	: iteration 12.0: start=15183577, BFS took 	0.573093	s, covered 	365	 edges, discovered 	291	 verts, TEPS incl. filtered edges=	506,673	, TEPS=	636	 
12464064.000000	: iteration 13.0: start=14039705, BFS took 	0.968328	s, covered 	68809	 edges, discovered 	43058	 verts, TEPS incl. filtered edges=	62,232,401	, TEPS=	71,059	 

BFS execution times (SejitsSR_SejitsFilter_OTF)
            min_SejitsSR_SejitsFilter_OTFtime	12464064.000000	: 	5.73092937469482422e-01
  firstquartile_SejitsSR_SejitsFilter_OTFtime	12464064.000000	: 	1.05575996637344360e+00
         median_SejitsSR_SejitsFilter_OTFtime	12464064.000000	: 	1.12962198257446289e+00
  thirdquartile_SejitsSR_SejitsFilter_OTFtime	12464064.000000	: 	1.41074454784393311e+00
            max_SejitsSR_SejitsFilter_OTFtime	12464064.000000	: 	4.78700089454650879e+00
           mean_SejitsSR_SejitsFilter_OTFtime	12464064.000000	: 	1.41635821415827823e+00
         stddev_SejitsSR_SejitsFilter_OTFtime	12464064.000000	: 	1.04527562771797733e+00
          total_SejitsSR_SejitsFilter_OTFtime	12464064.000000	: 	1.841266e+01

number of edges traversed OTF
            min_SejitsSR_SejitsFilter_OTFnedge	12464064.000000	: 	3.65000000000000000e+02
  firstquartile_SejitsSR_SejitsFilter_OTFnedge	12464064.000000	: 	6.87450000000000000e+04
         median_SejitsSR_SejitsFilter_OTFnedge	12464064.000000	: 	6.87480000000000000e+04
  thirdquartile_SejitsSR_SejitsFilter_OTFnedge	12464064.000000	: 	6.87840000000000000e+04
            max_SejitsSR_SejitsFilter_OTFnedge	12464064.000000	: 	6.88990000000000000e+04
           mean_SejitsSR_SejitsFilter_OTFnedge	12464064.000000	: 	6.35079230769230780e+04
         stddev_SejitsSR_SejitsFilter_OTFnedge	12464064.000000	: 	1.89721377264201947e+04
          total_SejitsSR_SejitsFilter_OTFnedge	12464064.000000	: 	8.256030e+05

TEPS (SejitsSR_SejitsFilter_OTF)
            min_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	6.36894953917376597e+02
  firstquartile_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	4.18974275158656455e+04
         median_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	6.06858844011291585e+04
  thirdquartile_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	6.32316261120961281e+04
            max_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	7.10595997047368728e+04
  harmonic_mean_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	7.10560933651455889e+03
harmonic_stddev_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	5.32923622044071635e+02

TEPS including filtered edges (SejitsSR_SejitsFilter_OTF)
            min_IncFiltered_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	5.06673492229979602e+05
  firstquartile_IncFiltered_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	3.67033147585695013e+07
         median_IncFiltered_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	5.31839595988565311e+07
  thirdquartile_IncFiltered_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	5.54236667866340652e+07
            max_IncFiltered_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	6.22324016811207384e+07
  harmonic_mean_IncFiltered_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	5.72761332825182471e+06
harmonic_stddev_IncFiltered_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	4.33372286966980260e+05
Total runtime for sso on 1246406400% is	202.773728	s.
Total runtime for everything is		332.226825
