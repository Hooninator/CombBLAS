-- Will be using pre-selected starting vertices for huge: [14472363, 13699402, 3890644, 14569240, 5705911, 394273, 7630462, 13303812, 754337, 9095300, 10736458, 15183577, 14039705]
--Reading network from /home/aydin/twitter/twitter_from06_to-12.induced.bin.remapped.bin.converted.balanced
Read in 86.630253s. Read 	16819398	 vertices and 	721043215	 edges.
--calculating degrees on original graph
Calculated in 31.127809s.
--Generating starting verts
Generated starting verts in 79.261236s.
--Doing BFS
12464064.000000	: iteration 1.0: start=14472363, BFS took 	5.510179	s, covered 	442233	 edges, discovered 	43019	 verts, TEPS incl. filtered edges=	130,856,585	, TEPS=	80,257	 
12464064.000000	: iteration 2.0: start=13699402, BFS took 	5.952745	s, covered 	442233	 edges, discovered 	43046	 verts, TEPS incl. filtered edges=	121,127,852	, TEPS=	74,290	 
12464064.000000	: iteration 3.0: start= 3890644, BFS took 	8.618529	s, covered 	442233	 edges, discovered 	43025	 verts, TEPS incl. filtered edges=	83,661,980	, TEPS=	51,311	 
12464064.000000	: iteration 4.0: start=14569240, BFS took 	4.425022	s, covered 	442233	 edges, discovered 	43019	 verts, TEPS incl. filtered edges=	162,946,813	, TEPS=	99,939	 
12464064.000000	: iteration 5.0: start= 5705911, BFS took 	4.432726	s, covered 	442233	 edges, discovered 	43022	 verts, TEPS incl. filtered edges=	162,663,613	, TEPS=	99,765	 
12464064.000000	: iteration 6.0: start=  394273, BFS took 	4.352960	s, covered 	442233	 edges, discovered 	43019	 verts, TEPS incl. filtered edges=	165,644,342	, TEPS=	101,593	 
12464064.000000	: iteration 7.0: start= 7630462, BFS took 	5.197559	s, covered 	442233	 edges, discovered 	43020	 verts, TEPS incl. filtered edges=	138,727,275	, TEPS=	85,084	 
12464064.000000	: iteration 8.0: start=13303812, BFS took 	4.957264	s, covered 	442233	 edges, discovered 	43142	 verts, TEPS incl. filtered edges=	145,451,850	, TEPS=	89,209	 
12464064.000000	: iteration 9.0: start=  754337, BFS took 	4.313061	s, covered 	442233	 edges, discovered 	43019	 verts, TEPS incl. filtered edges=	167,176,679	, TEPS=	102,533	 
12464064.000000	: iteration 10.0: start= 9095300, BFS took 	4.434786	s, covered 	442233	 edges, discovered 	43022	 verts, TEPS incl. filtered edges=	162,588,057	, TEPS=	99,719	 
12464064.000000	: iteration 11.0: start=10736458, BFS took 	4.475233	s, covered 	442233	 edges, discovered 	43029	 verts, TEPS incl. filtered edges=	161,118,583	, TEPS=	98,817	 
12464064.000000	: iteration 12.0: start=15183577, BFS took 	0.690204	s, covered 	442233	 edges, discovered 	291	 verts, TEPS incl. filtered edges=	1,044,681,447	, TEPS=	640,728	 
12464064.000000	: iteration 13.0: start=14039705, BFS took 	4.215395	s, covered 	442233	 edges, discovered 	43058	 verts, TEPS incl. filtered edges=	171,049,977	, TEPS=	104,909	 

BFS execution times (PythonSR_PythonFilter_OTF)
            min_PythonSR_PythonFilter_OTFtime	12464064.000000	: 	6.90203905105590820e-01
  firstquartile_PythonSR_PythonFilter_OTFtime	12464064.000000	: 	4.32303577661514282e+00
         median_PythonSR_PythonFilter_OTFtime	12464064.000000	: 	4.43478584289550781e+00
  thirdquartile_PythonSR_PythonFilter_OTFtime	12464064.000000	: 	5.43202406167984009e+00
            max_PythonSR_PythonFilter_OTFtime	12464064.000000	: 	8.61852908134460449e+00
           mean_PythonSR_PythonFilter_OTFtime	12464064.000000	: 	4.73658945010258581e+00
         stddev_PythonSR_PythonFilter_OTFtime	12464064.000000	: 	1.70118458982841037e+00
          total_PythonSR_PythonFilter_OTFtime	12464064.000000	: 	6.157566e+01

number of edges traversed OTF
            min_PythonSR_PythonFilter_OTFnedge	12464064.000000	: 	4.42233000000000000e+05
  firstquartile_PythonSR_PythonFilter_OTFnedge	12464064.000000	: 	4.42233000000000000e+05
         median_PythonSR_PythonFilter_OTFnedge	12464064.000000	: 	4.42233000000000000e+05
  thirdquartile_PythonSR_PythonFilter_OTFnedge	12464064.000000	: 	4.42233000000000000e+05
            max_PythonSR_PythonFilter_OTFnedge	12464064.000000	: 	4.42233000000000000e+05
           mean_PythonSR_PythonFilter_OTFnedge	12464064.000000	: 	4.42233000000000000e+05
         stddev_PythonSR_PythonFilter_OTFnedge	12464064.000000	: 	0.00000000000000000e+00
          total_PythonSR_PythonFilter_OTFnedge	12464064.000000	: 	5.749029e+06

TEPS (PythonSR_PythonFilter_OTF)
            min_PythonSR_PythonFilter_OTF_TEPS	12464064.000000	: 	5.13118881222137497e+04
  firstquartile_PythonSR_PythonFilter_OTF_TEPS	12464064.000000	: 	8.14642851474980562e+04
         median_PythonSR_PythonFilter_OTF_TEPS	12464064.000000	: 	9.97191331591476483e+04
  thirdquartile_PythonSR_PythonFilter_OTF_TEPS	12464064.000000	: 	1.02298489698859106e+05
            max_PythonSR_PythonFilter_OTF_TEPS	12464064.000000	: 	6.40728046782559133e+05
  harmonic_mean_PythonSR_PythonFilter_OTF_TEPS	12464064.000000	: 	9.33652799464015116e+04
harmonic_stddev_PythonSR_PythonFilter_OTF_TEPS	12464064.000000	: 	6.64669384233020628e+03

TEPS including filtered edges (PythonSR_PythonFilter_OTF)
            min_IncFiltered_PythonSR_PythonFilter_OTF_TEPS	12464064.000000	: 	8.36619808548012376e+07
  firstquartile_IncFiltered_PythonSR_PythonFilter_OTF_TEPS	12464064.000000	: 	1.32824257960009217e+08
         median_IncFiltered_PythonSR_PythonFilter_OTF_TEPS	12464064.000000	: 	1.62588057359095603e+08
  thirdquartile_IncFiltered_PythonSR_PythonFilter_OTF_TEPS	12464064.000000	: 	1.66793595010118544e+08
            max_IncFiltered_PythonSR_PythonFilter_OTF_TEPS	12464064.000000	: 	1.04468144799860442e+09
  harmonic_mean_IncFiltered_PythonSR_PythonFilter_OTF_TEPS	12464064.000000	: 	1.52228353881163061e+08
harmonic_stddev_IncFiltered_PythonSR_PythonFilter_OTF_TEPS	12464064.000000	: 	1.08371684094006456e+07
Total runtime for ppo on 1246406400% is	5479.064662	s.

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
Created SEJITS filter for 	1246406400	% in	19.102500	s.
--Generating starting verts
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
Generated starting verts in 78.658281s.
--Doing BFS
12464064.000000	: iteration 1.0: start=14472363, BFS took 	2.588869	s, covered 	442233	 edges, discovered 	43019	 verts, TEPS incl. filtered edges=	278,516,701	, TEPS=	170,820	 
12464064.000000	: iteration 2.0: start=13699402, BFS took 	1.392253	s, covered 	442233	 edges, discovered 	43046	 verts, TEPS incl. filtered edges=	517,896,715	, TEPS=	317,638	 
12464064.000000	: iteration 3.0: start= 3890644, BFS took 	1.406694	s, covered 	442233	 edges, discovered 	43025	 verts, TEPS incl. filtered edges=	512,580,026	, TEPS=	314,377	 
12464064.000000	: iteration 4.0: start=14569240, BFS took 	1.360255	s, covered 	442233	 edges, discovered 	43019	 verts, TEPS incl. filtered edges=	530,079,443	, TEPS=	325,110	 
12464064.000000	: iteration 5.0: start= 5705911, BFS took 	1.407182	s, covered 	442233	 edges, discovered 	43022	 verts, TEPS incl. filtered edges=	512,402,252	, TEPS=	314,268	 
12464064.000000	: iteration 6.0: start=  394273, BFS took 	1.320796	s, covered 	442233	 edges, discovered 	43019	 verts, TEPS incl. filtered edges=	545,915,650	, TEPS=	334,823	 
12464064.000000	: iteration 7.0: start= 7630462, BFS took 	2.127796	s, covered 	442233	 edges, discovered 	43020	 verts, TEPS incl. filtered edges=	338,868,593	, TEPS=	207,836	 
12464064.000000	: iteration 8.0: start=13303812, BFS took 	1.861958	s, covered 	442233	 edges, discovered 	43142	 verts, TEPS incl. filtered edges=	387,249,983	, TEPS=	237,509	 
12464064.000000	: iteration 9.0: start=  754337, BFS took 	1.361660	s, covered 	442233	 edges, discovered 	43019	 verts, TEPS incl. filtered edges=	529,532,492	, TEPS=	324,774	 
12464064.000000	: iteration 10.0: start= 9095300, BFS took 	1.364935	s, covered 	442233	 edges, discovered 	43022	 verts, TEPS incl. filtered edges=	528,261,973	, TEPS=	323,995	 
12464064.000000	: iteration 11.0: start=10736458, BFS took 	1.408506	s, covered 	442233	 edges, discovered 	43029	 verts, TEPS incl. filtered edges=	511,920,614	, TEPS=	313,973	 
12464064.000000	: iteration 12.0: start=15183577, BFS took 	0.703214	s, covered 	442233	 edges, discovered 	291	 verts, TEPS incl. filtered edges=	1,025,353,998	, TEPS=	628,874	 
12464064.000000	: iteration 13.0: start=14039705, BFS took 	1.184199	s, covered 	442233	 edges, discovered 	43058	 verts, TEPS incl. filtered edges=	608,886,814	, TEPS=	373,444	 

BFS execution times (PythonSR_SejitsFilter_OTF)
            min_PythonSR_SejitsFilter_OTFtime	12464064.000000	: 	7.03213930130004883e-01
  firstquartile_PythonSR_SejitsFilter_OTFtime	12464064.000000	: 	1.33066076040267944e+00
         median_PythonSR_SejitsFilter_OTFtime	12464064.000000	: 	1.39225292205810547e+00
  thirdquartile_PythonSR_SejitsFilter_OTFtime	12464064.000000	: 	1.74859499931335449e+00
            max_PythonSR_SejitsFilter_OTFtime	12464064.000000	: 	2.58886885643005371e+00
           mean_PythonSR_SejitsFilter_OTFtime	12464064.000000	: 	1.49910127199613141e+00
         stddev_PythonSR_SejitsFilter_OTFtime	12464064.000000	: 	4.62933540783514064e-01
          total_PythonSR_SejitsFilter_OTFtime	12464064.000000	: 	1.948832e+01

number of edges traversed OTF
            min_PythonSR_SejitsFilter_OTFnedge	12464064.000000	: 	4.42233000000000000e+05
  firstquartile_PythonSR_SejitsFilter_OTFnedge	12464064.000000	: 	4.42233000000000000e+05
         median_PythonSR_SejitsFilter_OTFnedge	12464064.000000	: 	4.42233000000000000e+05
  thirdquartile_PythonSR_SejitsFilter_OTFnedge	12464064.000000	: 	4.42233000000000000e+05
            max_PythonSR_SejitsFilter_OTFnedge	12464064.000000	: 	4.42233000000000000e+05
           mean_PythonSR_SejitsFilter_OTFnedge	12464064.000000	: 	4.42233000000000000e+05
         stddev_PythonSR_SejitsFilter_OTFnedge	12464064.000000	: 	0.00000000000000000e+00
          total_PythonSR_SejitsFilter_OTFnedge	12464064.000000	: 	5.749029e+06

TEPS (PythonSR_SejitsFilter_OTF)
            min_PythonSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	1.70820935522327520e+05
  firstquartile_PythonSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	2.56625518291825400e+05
         median_PythonSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	3.17638406781913363e+05
  thirdquartile_PythonSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	3.32394907354909927e+05
            max_PythonSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	6.28874061010485515e+05
  harmonic_mean_PythonSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	2.94998749091276317e+05
harmonic_stddev_PythonSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	1.30514737203988698e+04

TEPS including filtered edges (PythonSR_SejitsFilter_OTF)
            min_IncFiltered_PythonSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	2.78516701689667523e+08
  firstquartile_IncFiltered_PythonSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	4.18417641289046943e+08
         median_IncFiltered_PythonSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	5.17896715155830979e+08
  thirdquartile_IncFiltered_PythonSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	5.41956599007336497e+08
            max_IncFiltered_PythonSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	1.02535399841510391e+09
  harmonic_mean_IncFiltered_PythonSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	4.80983658989157915e+08
harmonic_stddev_IncFiltered_PythonSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	2.12799057778239399e+07
Total runtime for pso on 1246406400% is	5399.333463	s.

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
Created SEJITS filter for 	1246406400	% in	0.051103	s.
--Generating starting verts
Generated starting verts in 74.891781s.
--Doing BFS
12464064.000000	: iteration 1.0: start=14472363, BFS took 	1.498723	s, covered 	442233	 edges, discovered 	43019	 verts, TEPS incl. filtered edges=	481,105,047	, TEPS=	295,073	 
12464064.000000	: iteration 2.0: start=13699402, BFS took 	1.503533	s, covered 	442233	 edges, discovered 	43046	 verts, TEPS incl. filtered edges=	479,565,975	, TEPS=	294,129	 
12464064.000000	: iteration 3.0: start= 3890644, BFS took 	1.482676	s, covered 	442233	 edges, discovered 	43025	 verts, TEPS incl. filtered edges=	486,312,047	, TEPS=	298,266	 
12464064.000000	: iteration 4.0: start=14569240, BFS took 	1.458078	s, covered 	442233	 edges, discovered 	43019	 verts, TEPS incl. filtered edges=	494,516,247	, TEPS=	303,298	 
12464064.000000	: iteration 5.0: start= 5705911, BFS took 	1.540666	s, covered 	442233	 edges, discovered 	43022	 verts, TEPS incl. filtered edges=	468,007,522	, TEPS=	287,040	 
12464064.000000	: iteration 6.0: start=  394273, BFS took 	1.420633	s, covered 	442233	 edges, discovered 	43019	 verts, TEPS incl. filtered edges=	507,550,631	, TEPS=	311,292	 
12464064.000000	: iteration 7.0: start= 7630462, BFS took 	2.328425	s, covered 	442233	 edges, discovered 	43020	 verts, TEPS incl. filtered edges=	309,669,911	, TEPS=	189,927	 
12464064.000000	: iteration 8.0: start=13303812, BFS took 	2.048579	s, covered 	442233	 edges, discovered 	43142	 verts, TEPS incl. filtered edges=	351,972,378	, TEPS=	215,873	 
12464064.000000	: iteration 9.0: start=  754337, BFS took 	1.506866	s, covered 	442233	 edges, discovered 	43019	 verts, TEPS incl. filtered edges=	478,505,205	, TEPS=	293,478	 
12464064.000000	: iteration 10.0: start= 9095300, BFS took 	1.523526	s, covered 	442233	 edges, discovered 	43022	 verts, TEPS incl. filtered edges=	473,272,682	, TEPS=	290,269	 
12464064.000000	: iteration 11.0: start=10736458, BFS took 	1.576140	s, covered 	442233	 edges, discovered 	43029	 verts, TEPS incl. filtered edges=	457,474,112	, TEPS=	280,579	 
12464064.000000	: iteration 12.0: start=15183577, BFS took 	0.772248	s, covered 	442233	 edges, discovered 	291	 verts, TEPS incl. filtered edges=	933,693,822	, TEPS=	572,656	 
12464064.000000	: iteration 13.0: start=14039705, BFS took 	1.300278	s, covered 	442233	 edges, discovered 	43058	 verts, TEPS incl. filtered edges=	554,530,064	, TEPS=	340,106	 

BFS execution times (SejitsSR_SejitsFilter_OTF)
            min_SejitsSR_SejitsFilter_OTFtime	12464064.000000	: 	7.72248029708862305e-01
  firstquartile_SejitsSR_SejitsFilter_OTFtime	12464064.000000	: 	1.42999428510665894e+00
         median_SejitsSR_SejitsFilter_OTFtime	12464064.000000	: 	1.50353288650512695e+00
  thirdquartile_SejitsSR_SejitsFilter_OTFtime	12464064.000000	: 	1.56727141141891479e+00
            max_SejitsSR_SejitsFilter_OTFtime	12464064.000000	: 	2.32842516899108887e+00
           mean_SejitsSR_SejitsFilter_OTFtime	12464064.000000	: 	1.53541313684903669e+00
         stddev_SejitsSR_SejitsFilter_OTFtime	12464064.000000	: 	3.60191873093976267e-01
          total_SejitsSR_SejitsFilter_OTFtime	12464064.000000	: 	1.996037e+01

number of edges traversed OTF
            min_SejitsSR_SejitsFilter_OTFnedge	12464064.000000	: 	4.42233000000000000e+05
  firstquartile_SejitsSR_SejitsFilter_OTFnedge	12464064.000000	: 	4.42233000000000000e+05
         median_SejitsSR_SejitsFilter_OTFnedge	12464064.000000	: 	4.42233000000000000e+05
  thirdquartile_SejitsSR_SejitsFilter_OTFnedge	12464064.000000	: 	4.42233000000000000e+05
            max_SejitsSR_SejitsFilter_OTFnedge	12464064.000000	: 	4.42233000000000000e+05
           mean_SejitsSR_SejitsFilter_OTFnedge	12464064.000000	: 	4.42233000000000000e+05
         stddev_SejitsSR_SejitsFilter_OTFnedge	12464064.000000	: 	0.00000000000000000e+00
          total_SejitsSR_SejitsFilter_OTFnedge	12464064.000000	: 	5.749029e+06

TEPS (SejitsSR_SejitsFilter_OTF)
            min_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	1.89927941807818715e+05
  firstquartile_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	2.82194881715527619e+05
         median_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	2.94129249828345550e+05
  thirdquartile_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	3.09294332027243800e+05
            max_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	5.72656689285075874e+05
  harmonic_mean_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	2.88022154680496722e+05
harmonic_stddev_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	1.19299301959956756e+04

TEPS including filtered edges (SejitsSR_SejitsFilter_OTF)
            min_IncFiltered_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	3.09669911063721001e+08
  firstquartile_IncFiltered_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	4.60107465450811625e+08
         median_IncFiltered_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	4.79565975225205898e+08
  thirdquartile_IncFiltered_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	5.04292035072464883e+08
            max_IncFiltered_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	9.33693822788817525e+08
  harmonic_mean_IncFiltered_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	4.69608600900549471e+08
harmonic_stddev_IncFiltered_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	1.94512739285541810e+07
Total runtime for sso on 1246406400% is	5377.973321	s.
Total runtime for everything is		16411.709103
