--Reading network from /home/aydin/twitter/twitter_from06_to-06.induced.bin.remapped.bin.converted.balanced
Read in 4.469429s. Read 	526319	 vertices and 	65363924	 edges.
--calculating degrees on original graph
Calculated in 2.846695s.
--Generating starting verts
Generated starting verts in 7.228048s.
--Doing BFS
12464064.000000	: iteration  1: start=  219486, BFS took 	0.002881	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	22,687,534,582	, TEPS=	241,579,623	 (result discarded)
12464064.000000	: iteration  2: start=  524837, BFS took 	0.003446	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	18,968,807,021	, TEPS=	201,982,160	 (result discarded)
12464064.000000	: iteration  3: start=  379120, BFS took 	0.003804	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	17,183,087,927	, TEPS=	182,967,606	 (result discarded)
12464064.000000	: iteration  4: start=  490822, BFS took 	0.001559	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	41,926,314,098	, TEPS=	446,436,483	 (result discarded)
12464064.000000	: iteration  5: start=      60, BFS took 	0.001522	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	42,944,261,887	, TEPS=	457,275,715	 (result discarded)
12464064.000000	: iteration  6: start=   67434, BFS took 	0.004462	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	14,649,007,100	, TEPS=	155,984,406	 (result discarded)
12464064.000000	: iteration  7: start=  159123, BFS took 	0.002943	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	22,209,670,114	, TEPS=	236,491,264	 (result discarded)
12464064.000000	: iteration  8: start=  525814, BFS took 	0.001848	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	35,370,425,479	, TEPS=	376,628,585	 (result discarded)
12464064.000000	: iteration  9: start=   77240, BFS took 	0.005712	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	11,443,199,260	, TEPS=	121,848,575	 (result discarded)
12464064.000000	: iteration 10: start=  124258, BFS took 	0.005259	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	12,428,876,955	, TEPS=	132,344,191	 (result discarded)
12464064.000000	: iteration 11: start=   48599, BFS took 	0.002876	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	22,727,030,414	, TEPS=	242,000,179	 (result discarded)
12464064.000000	: iteration 12: start=  208727, BFS took 	1.556003	s, covered 	696003	 edges, discovered 	78399	 verts, TEPS incl. filtered edges=	42,007,579	, TEPS=	447,301	 
12464064.000000	: iteration 13: start=   98032, BFS took 	0.003404	s, covered 	696003	 edges, discovered 	6	 verts, TEPS incl. filtered edges=	19,202,645,365	, TEPS=	204,472,099	 (result discarded)
12464064.000000	: iteration 14: start=  204164, BFS took 	0.002386	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	27,396,439,281	, TEPS=	291,720,612	 (result discarded)
12464064.000000	: iteration 15: start=  181875, BFS took 	0.060802	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	1,075,029,479	, TEPS=	11,447,044	 (result discarded)
12464064.000000	: iteration 16: start=  352500, BFS took 	0.002637	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	24,785,839,244	, TEPS=	263,922,626	 (result discarded)
12464064.000000	: iteration 17: start=  208826, BFS took 	0.002975	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	21,971,162,677	, TEPS=	233,951,608	 (result discarded)
12464064.000000	: iteration 18: start=  492391, BFS took 	0.005622	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	11,626,146,808	, TEPS=	123,796,622	 (result discarded)
12464064.000000	: iteration 19: start=  283589, BFS took 	0.001544	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	42,334,182,811	, TEPS=	450,779,519	 (result discarded)
12464064.000000	: iteration 20: start=  445429, BFS took 	0.004559	s, covered 	696003	 edges, discovered 	6	 verts, TEPS incl. filtered edges=	14,337,212,001	, TEPS=	152,664,374	 (result discarded)
12464064.000000	: iteration 21: start=  220630, BFS took 	0.003850	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	16,977,716,614	, TEPS=	180,780,788	 (result discarded)
12464064.000000	: iteration 22: start=  164881, BFS took 	0.001699	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	38,472,658,979	, TEPS=	409,661,544	 (result discarded)
12464064.000000	: iteration 23: start=  360644, BFS took 	0.002781	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	23,504,472,555	, TEPS=	250,278,477	 (result discarded)
12464064.000000	: iteration 24: start=  276079, BFS took 	0.003898	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	16,768,986,964	, TEPS=	178,558,209	 (result discarded)
12464064.000000	: iteration 25: start=  107607, BFS took 	0.001471	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	44,433,738,717	, TEPS=	473,135,845	 (result discarded)
12464064.000000	: iteration 26: start=  233397, BFS took 	0.003692	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	17,704,628,213	, TEPS=	188,521,031	 (result discarded)
12464064.000000	: iteration 27: start=  462169, BFS took 	0.001266	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	51,630,163,444	, TEPS=	549,764,249	 (result discarded)
12464064.000000	: iteration 28: start=  120830, BFS took 	0.004430	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	14,754,650,873	, TEPS=	157,109,314	 (result discarded)
12464064.000000	: iteration 29: start=   14414, BFS took 	0.001747	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	37,412,140,814	, TEPS=	398,369,018	 (result discarded)
12464064.000000	: iteration 30: start=  281272, BFS took 	0.001253	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	52,170,536,230	, TEPS=	555,518,204	 (result discarded)
12464064.000000	: iteration 31: start=  352879, BFS took 	0.003025	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	21,607,516,384	, TEPS=	230,079,458	 (result discarded)
12464064.000000	: iteration 32: start=  481035, BFS took 	0.003567	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	18,324,722,136	, TEPS=	195,123,866	 (result discarded)
12464064.000000	: iteration 33: start=  219635, BFS took 	0.002732	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	23,924,964,472	, TEPS=	254,755,926	 (result discarded)
12464064.000000	: iteration 34: start=  240635, BFS took 	0.004442	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	14,715,053,829	, TEPS=	156,687,680	 (result discarded)
12464064.000000	: iteration 35: start=  294049, BFS took 	0.001767	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	36,988,150,011	, TEPS=	393,854,312	 (result discarded)
12464064.000000	: iteration 36: start=  226684, BFS took 	1.600635	s, covered 	696003	 edges, discovered 	78420	 verts, TEPS incl. filtered edges=	40,836,244	, TEPS=	434,829	 
12464064.000000	: iteration 37: start=   73888, BFS took 	0.003839	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	17,026,218,351	, TEPS=	181,297,240	 (result discarded)
12464064.000000	: iteration 38: start=  494280, BFS took 	0.001373	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	47,613,089,247	, TEPS=	506,989,956	 (result discarded)
12464064.000000	: iteration 39: start=  104264, BFS took 	0.001490	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	43,872,006,383	, TEPS=	467,154,451	 (result discarded)
12464064.000000	: iteration 40: start=  409681, BFS took 	0.004310	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	15,166,021,346	, TEPS=	161,489,636	 (result discarded)
12464064.000000	: iteration 41: start=  421447, BFS took 	0.001539	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	42,471,908,270	, TEPS=	452,246,036	 (result discarded)
12464064.000000	: iteration 42: start=  376828, BFS took 	0.006918	s, covered 	696003	 edges, discovered 	16	 verts, TEPS incl. filtered edges=	9,448,448,024	, TEPS=	100,608,221	 (result discarded)
12464064.000000	: iteration 43: start=  509614, BFS took 	0.007020	s, covered 	696003	 edges, discovered 	8	 verts, TEPS incl. filtered edges=	9,311,104,737	, TEPS=	99,145,773	 (result discarded)
12464064.000000	: iteration 44: start=  422506, BFS took 	0.001302	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	50,202,557,752	, TEPS=	534,562,931	 (result discarded)
12464064.000000	: iteration 45: start=  164961, BFS took 	0.002558	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	25,552,816,468	, TEPS=	272,089,492	 (result discarded)
12464064.000000	: iteration 46: start=   48842, BFS took 	1.594430	s, covered 	696003	 edges, discovered 	78410	 verts, TEPS incl. filtered edges=	40,995,161	, TEPS=	436,521	 
12464064.000000	: iteration 47: start=  364382, BFS took 	0.001132	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	57,741,400,145	, TEPS=	614,837,440	 (result discarded)
12464064.000000	: iteration 48: start=  272713, BFS took 	1.559909	s, covered 	696003	 edges, discovered 	78398	 verts, TEPS incl. filtered edges=	41,902,399	, TEPS=	446,181	 
12464064.000000	: iteration 49: start=  461260, BFS took 	0.005059	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	12,920,315,183	, TEPS=	137,577,085	 (result discarded)
12464064.000000	: iteration 50: start=  455276, BFS took 	0.005032	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	12,990,105,088	, TEPS=	138,320,216	 (result discarded)
12464064.000000	: iteration 51: start=  470848, BFS took 	1.684674	s, covered 	696003	 edges, discovered 	78418	 verts, TEPS incl. filtered edges=	38,799,152	, TEPS=	413,138	 
12464064.000000	: iteration 52: start=  436395, BFS took 	0.001702	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	38,402,600,908	, TEPS=	408,915,557	 (result discarded)
12464064.000000	: iteration 53: start=   44760, BFS took 	0.005370	s, covered 	696003	 edges, discovered 	4	 verts, TEPS incl. filtered edges=	12,172,275,802	, TEPS=	129,611,870	 (result discarded)
12464064.000000	: iteration 54: start=  436636, BFS took 	0.002694	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	24,261,607,777	, TEPS=	258,340,545	 (result discarded)
12464064.000000	: iteration 55: start=   20555, BFS took 	1.599308	s, covered 	696003	 edges, discovered 	78397	 verts, TEPS incl. filtered edges=	40,870,128	, TEPS=	435,190	 
12464064.000000	: iteration 56: start=  143711, BFS took 	0.004867	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	13,429,811,300	, TEPS=	143,002,261	 (result discarded)
12464064.000000	: iteration 57: start=   89384, BFS took 	0.001392	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	46,952,589,122	, TEPS=	499,956,870	 (result discarded)
12464064.000000	: iteration 58: start=   31180, BFS took 	0.001485	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	44,012,870,105	, TEPS=	468,654,385	 (result discarded)
12464064.000000	: iteration 59: start=  462183, BFS took 	0.005635	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	11,599,584,002	, TEPS=	123,513,779	 (result discarded)
12464064.000000	: iteration 60: start=  352911, BFS took 	1.620015	s, covered 	696003	 edges, discovered 	78401	 verts, TEPS incl. filtered edges=	40,347,729	, TEPS=	429,627	 
12464064.000000	: iteration 61: start=   51761, BFS took 	0.001114	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	58,680,686,620	, TEPS=	624,839,076	 (result discarded)
12464064.000000	: iteration 62: start=  312141, BFS took 	0.003945	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	16,569,332,037	, TEPS=	176,432,259	 (result discarded)
12464064.000000	: iteration 63: start=  221636, BFS took 	1.556289	s, covered 	696003	 edges, discovered 	78400	 verts, TEPS incl. filtered edges=	41,999,863	, TEPS=	447,219	 
12464064.000000	: iteration 64: start=  353504, BFS took 	0.001171	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	55,813,552,094	, TEPS=	594,309,480	 (result discarded)
12464064.000000	: iteration 65: start=  504155, BFS took 	0.005031	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	12,991,951,847	, TEPS=	138,339,880	 (result discarded)
12464064.000000	: iteration 66: start=  216731, BFS took 	0.005145	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	12,704,767,036	, TEPS=	135,281,902	 (result discarded)
12464064.000000	: iteration 67: start=  280615, BFS took 	0.005009	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	13,049,462,986	, TEPS=	138,952,266	 (result discarded)
12464064.000000	: iteration 68: start=  103974, BFS took 	0.005163	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	12,660,178,614	, TEPS=	134,807,119	 (result discarded)
12464064.000000	: iteration 69: start=  364148, BFS took 	0.001584	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	41,269,933,447	, TEPS=	439,447,262	 (result discarded)
12464064.000000	: iteration 70: start=  152437, BFS took 	0.002581	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	25,326,204,885	, TEPS=	269,676,505	 (result discarded)
12464064.000000	: iteration 71: start=  166061, BFS took 	0.006904	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	9,467,372,328	, TEPS=	100,809,730	 (result discarded)
12464064.000000	: iteration 72: start=   74800, BFS took 	1.569508	s, covered 	696003	 edges, discovered 	78400	 verts, TEPS incl. filtered edges=	41,646,121	, TEPS=	443,452	 
12464064.000000	: iteration 73: start=  361318, BFS took 	0.005103	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	12,809,240,194	, TEPS=	136,394,345	 (result discarded)
12464064.000000	: iteration 74: start=  412273, BFS took 	0.003596	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	18,177,706,397	, TEPS=	193,558,425	 (result discarded)
12464064.000000	: iteration 75: start=  439279, BFS took 	0.003082	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	21,208,027,221	, TEPS=	225,825,649	 (result discarded)
12464064.000000	: iteration 76: start=  217127, BFS took 	1.602272	s, covered 	696003	 edges, discovered 	78398	 verts, TEPS incl. filtered edges=	40,794,523	, TEPS=	434,385	 
12464064.000000	: iteration 77: start=    9625, BFS took 	0.004904	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	13,328,609,455	, TEPS=	141,924,651	 (result discarded)
12464064.000000	: iteration 78: start=   17985, BFS took 	0.002517	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	25,969,135,918	, TEPS=	276,522,512	 (result discarded)
12464064.000000	: iteration 79: start=  394815, BFS took 	1.586825	s, covered 	696003	 edges, discovered 	78399	 verts, TEPS incl. filtered edges=	41,191,642	, TEPS=	438,613	 
12464064.000000	: iteration 80: start=  328438, BFS took 	0.004497	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	14,534,840,838	, TEPS=	154,768,750	 (result discarded)
12464064.000000	: iteration 81: start=  520456, BFS took 	0.001896	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	34,476,379,261	, TEPS=	367,108,672	 (result discarded)
12464064.000000	: iteration 82: start=  347705, BFS took 	0.002848	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	22,951,541,891	, TEPS=	244,390,805	 (result discarded)
12464064.000000	: iteration 83: start=  393773, BFS took 	0.005058	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	12,922,751,255	, TEPS=	137,603,024	 (result discarded)
12464064.000000	: iteration 84: start=  157103, BFS took 	0.002757	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	23,709,778,421	, TEPS=	252,464,599	 (result discarded)
12464064.000000	: iteration 85: start=  147603, BFS took 	0.001704	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	38,359,614,927	, TEPS=	408,457,837	 (result discarded)
12464064.000000	: iteration 86: start=  234809, BFS took 	2.606064	s, covered 	696003	 edges, discovered 	78399	 verts, TEPS incl. filtered edges=	25,081,474	, TEPS=	267,070	 
12464064.000000	: iteration 87: start=  415412, BFS took 	0.001143	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	57,187,352,500	, TEPS=	608,937,873	 (result discarded)
12464064.000000	: iteration 88: start=  116908, BFS took 	0.004168	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	15,682,196,996	, TEPS=	166,985,937	 (result discarded)
12464064.000000	: iteration 89: start=   54329, BFS took 	0.001749	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	37,371,342,405	, TEPS=	397,934,592	 (result discarded)
12464064.000000	: iteration 90: start=   38612, BFS took 	0.002795	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	23,386,178,272	, TEPS=	249,018,866	 (result discarded)
12464064.000000	: iteration 91: start=  235734, BFS took 	0.004036	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	16,195,425,796	, TEPS=	172,450,860	 (result discarded)
12464064.000000	: iteration 92: start=  246969, BFS took 	0.003077	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	21,242,535,866	, TEPS=	226,193,101	 (result discarded)
12464064.000000	: iteration 93: start=  478211, BFS took 	0.001306	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	50,055,900,655	, TEPS=	533,001,308	 (result discarded)
12464064.000000	: iteration 94: start=   50617, BFS took 	0.004031	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	16,215,541,958	, TEPS=	172,665,059	 (result discarded)
12464064.000000	: iteration 95: start=  154534, BFS took 	0.002911	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	22,453,412,603	, TEPS=	239,086,663	 (result discarded)
12464064.000000	: iteration 96: start=  475460, BFS took 	1.576527	s, covered 	696003	 edges, discovered 	78406	 verts, TEPS incl. filtered edges=	41,460,710	, TEPS=	441,478	 
12464064.000000	: iteration 97: start=  151461, BFS took 	0.003617	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	18,071,067,687	, TEPS=	192,422,923	 (result discarded)
12464064.000000	: iteration 98: start=   62890, BFS took 	0.001833	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	35,660,271,577	, TEPS=	379,714,902	 (result discarded)
12464064.000000	: iteration 99: start=   68436, BFS took 	0.002671	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	24,471,674,363	, TEPS=	260,577,360	 (result discarded)
12464064.000000	: iteration 100: start=  276211, BFS took 	0.005357	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	12,201,529,569	, TEPS=	129,923,368	 (result discarded)
12464064.000000	: iteration 101: start=   10193, BFS took 	0.001463	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	44,679,949,134	, TEPS=	475,757,523	 (result discarded)
12464064.000000	: iteration 102: start=   44012, BFS took 	1.610181	s, covered 	696003	 edges, discovered 	78403	 verts, TEPS incl. filtered edges=	40,594,150	, TEPS=	432,251	 
12464064.000000	: iteration 103: start=  357284, BFS took 	0.003805	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	17,178,781,119	, TEPS=	182,921,747	 (result discarded)
12464064.000000	: iteration 104: start=  482561, BFS took 	0.001586	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	41,214,096,194	, TEPS=	438,852,700	 (result discarded)
12464064.000000	: iteration 105: start=  111383, BFS took 	0.001887	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	34,641,921,643	, TEPS=	368,871,388	 (result discarded)
12464064.000000	: iteration 106: start=  479186, BFS took 	0.004522	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	14,454,376,964	, TEPS=	153,911,961	 (result discarded)
12464064.000000	: iteration 107: start=  139762, BFS took 	0.001755	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	37,244,418,949	, TEPS=	396,583,095	 (result discarded)
12464064.000000	: iteration 108: start=  157332, BFS took 	0.005124	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	12,756,196,160	, TEPS=	135,829,525	 (result discarded)
12464064.000000	: iteration 109: start=  258724, BFS took 	1.565118	s, covered 	696003	 edges, discovered 	78398	 verts, TEPS incl. filtered edges=	41,762,934	, TEPS=	444,696	 
12464064.000000	: iteration 110: start=  307575, BFS took 	0.003985	s, covered 	696003	 edges, discovered 	4	 verts, TEPS incl. filtered edges=	16,402,786,160	, TEPS=	174,658,858	 (result discarded)
12464064.000000	: iteration 111: start=   28085, BFS took 	0.008921	s, covered 	696003	 edges, discovered 	15	 verts, TEPS incl. filtered edges=	7,326,852,527	, TEPS=	78,017,215	 (result discarded)
12464064.000000	: iteration 112: start=  297850, BFS took 	0.001973	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	33,130,654,729	, TEPS=	352,779,234	 (result discarded)
12464064.000000	: iteration 113: start=  302169, BFS took 	0.002887	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	22,640,694,350	, TEPS=	241,080,862	 (result discarded)
12464064.000000	: iteration 114: start=  323127, BFS took 	0.003865	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	16,911,736,961	, TEPS=	180,078,228	 (result discarded)
12464064.000000	: iteration 115: start=   77226, BFS took 	0.011892	s, covered 	696003	 edges, discovered 	60	 verts, TEPS incl. filtered edges=	5,496,534,902	, TEPS=	58,527,771	 (result discarded)
12464064.000000	: iteration 116: start=  503442, BFS took 	0.002683	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	24,360,775,536	, TEPS=	259,396,496	 (result discarded)
12464064.000000	: iteration 117: start=  310162, BFS took 	0.003722	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	17,560,605,168	, TEPS=	186,987,456	 (result discarded)
12464064.000000	: iteration 118: start=  137358, BFS took 	0.003941	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	16,585,370,108	, TEPS=	176,603,034	 (result discarded)
12464064.000000	: iteration 119: start=  368296, BFS took 	0.002881	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	22,687,534,582	, TEPS=	241,579,623	 (result discarded)
12464064.000000	: iteration 120: start=  121587, BFS took 	0.007645	s, covered 	696003	 edges, discovered 	5	 verts, TEPS incl. filtered edges=	8,549,746,394	, TEPS=	91,038,737	 (result discarded)
12464064.000000	: iteration 121: start=   53860, BFS took 	0.002693	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	24,272,347,754	, TEPS=	258,454,906	 (result discarded)
12464064.000000	: iteration 122: start=  280764, BFS took 	0.001808	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	36,154,050,888	, TEPS=	384,972,724	 (result discarded)
12464064.000000	: iteration 123: start=  217925, BFS took 	0.003637	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	17,971,561,316	, TEPS=	191,363,367	 (result discarded)
12464064.000000	: iteration 124: start=  499970, BFS took 	0.001536	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	42,551,011,623	, TEPS=	453,088,338	 (result discarded)
12464064.000000	: iteration 125: start=  365475, BFS took 	0.001531	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	42,690,153,828	, TEPS=	454,569,941	 (result discarded)
12464064.000000	: iteration 126: start=  259506, BFS took 	1.577333	s, covered 	696003	 edges, discovered 	78404	 verts, TEPS incl. filtered edges=	41,439,521	, TEPS=	441,253	 

BFS execution times (PythonSR_PythonFilter_OTF)
            min_PythonSR_PythonFilter_OTFtime	12464064.000000	: 	1.55600309371948242e+00
  firstquartile_PythonSR_PythonFilter_OTFtime	12464064.000000	: 	1.56621557474136353e+00
         median_PythonSR_PythonFilter_OTFtime	12464064.000000	: 	1.59062755107879639e+00
  thirdquartile_PythonSR_PythonFilter_OTFtime	12464064.000000	: 	1.60820364952087402e+00
            max_PythonSR_PythonFilter_OTFtime	12464064.000000	: 	2.60606384277343750e+00
           mean_PythonSR_PythonFilter_OTFtime	12464064.000000	: 	1.65406817197799683e+00
         stddev_PythonSR_PythonFilter_OTFtime	12464064.000000	: 	2.55856748557987568e-01
          total_PythonSR_PythonFilter_OTFtime	12464064.000000	: 	2.646509e+01

number of edges traversed OTF
            min_PythonSR_PythonFilter_OTFnedge	12464064.000000	: 	6.96003000000000000e+05
  firstquartile_PythonSR_PythonFilter_OTFnedge	12464064.000000	: 	6.96003000000000000e+05
         median_PythonSR_PythonFilter_OTFnedge	12464064.000000	: 	6.96003000000000000e+05
  thirdquartile_PythonSR_PythonFilter_OTFnedge	12464064.000000	: 	6.96003000000000000e+05
            max_PythonSR_PythonFilter_OTFnedge	12464064.000000	: 	6.96003000000000000e+05
           mean_PythonSR_PythonFilter_OTFnedge	12464064.000000	: 	6.96003000000000000e+05
         stddev_PythonSR_PythonFilter_OTFnedge	12464064.000000	: 	0.00000000000000000e+00
          total_PythonSR_PythonFilter_OTFnedge	12464064.000000	: 	1.113605e+07

TEPS (PythonSR_PythonFilter_OTF)
            min_PythonSR_PythonFilter_OTF_TEPS	12464064.000000	: 	2.67070586904462194e+05
  firstquartile_PythonSR_PythonFilter_OTF_TEPS	12464064.000000	: 	4.32784842966618075e+05
         median_PythonSR_PythonFilter_OTF_TEPS	12464064.000000	: 	4.37567535782401275e+05
  thirdquartile_PythonSR_PythonFilter_OTF_TEPS	12464064.000000	: 	4.44385840022312012e+05
            max_PythonSR_PythonFilter_OTF_TEPS	12464064.000000	: 	4.47301809880254674e+05
  harmonic_mean_PythonSR_PythonFilter_OTF_TEPS	12464064.000000	: 	4.20782535926371987e+05
harmonic_stddev_PythonSR_PythonFilter_OTF_TEPS	12464064.000000	: 	1.66313468874304067e+03

TEPS including filtered edges (PythonSR_PythonFilter_OTF)
            min_IncFiltered_PythonSR_PythonFilter_OTF_TEPS	12464064.000000	: 	2.50814745698778033e+07
  firstquartile_IncFiltered_PythonSR_PythonFilter_OTF_TEPS	12464064.000000	: 	4.06442437518544570e+07
         median_IncFiltered_PythonSR_PythonFilter_OTF_TEPS	12464064.000000	: 	4.10934021171577722e+07
  thirdquartile_IncFiltered_PythonSR_PythonFilter_OTF_TEPS	12464064.000000	: 	4.17337314262935072e+07
            max_IncFiltered_PythonSR_PythonFilter_OTF_TEPS	12464064.000000	: 	4.20075797174371555e+07
  harmonic_mean_IncFiltered_PythonSR_PythonFilter_OTF_TEPS	12464064.000000	: 	3.95170677408267632e+07
harmonic_stddev_IncFiltered_PythonSR_PythonFilter_OTF_TEPS	12464064.000000	: 	1.56190432220498478e+05
Total runtime for ppo on 1246406400% is	1495.403293	s.

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
Created SEJITS filter for 	1246406400	% in	18.101260	s.
--Generating starting verts
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
Generated starting verts in 19.810719s.
--Doing BFS
12464064.000000	: iteration  1: start=  219486, BFS took 	0.003066	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	21,320,177,921	, TEPS=	227,019,843	 (result discarded)
12464064.000000	: iteration  2: start=  524837, BFS took 	0.005985	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	10,921,251,160	, TEPS=	116,290,808	 (result discarded)
12464064.000000	: iteration  3: start=  379120, BFS took 	0.001783	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	36,656,794,743	, TEPS=	390,326,001	 (result discarded)
12464064.000000	: iteration  4: start=  490822, BFS took 	0.001615	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	40,471,828,740	, TEPS=	430,948,946	 (result discarded)
12464064.000000	: iteration  5: start=      60, BFS took 	0.003686	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	17,733,257,948	, TEPS=	188,825,884	 (result discarded)
12464064.000000	: iteration  6: start=   67434, BFS took 	0.001302	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	50,202,557,752	, TEPS=	534,562,931	 (result discarded)
12464064.000000	: iteration  7: start=  159123, BFS took 	0.003265	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	20,018,705,212	, TEPS=	213,161,604	 (result discarded)
12464064.000000	: iteration  8: start=  525814, BFS took 	0.004001	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	16,336,322,720	, TEPS=	173,951,148	 (result discarded)
12464064.000000	: iteration  9: start=   77240, BFS took 	0.003546	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	18,433,145,154	, TEPS=	196,278,367	 (result discarded)
12464064.000000	: iteration 10: start=  124258, BFS took 	0.002847	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	22,959,230,205	, TEPS=	244,472,671	 (result discarded)
12464064.000000	: iteration 11: start=   48599, BFS took 	0.005098	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	12,821,820,591	, TEPS=	136,528,302	 (result discarded)
12464064.000000	: iteration 12: start=  208727, BFS took 	0.066251	s, covered 	696003	 edges, discovered 	78399	 verts, TEPS incl. filtered edges=	986,609,787	, TEPS=	10,505,540	 
12464064.000000	: iteration 13: start=   98032, BFS took 	0.002973	s, covered 	696003	 edges, discovered 	6	 verts, TEPS incl. filtered edges=	21,985,258,050	, TEPS=	234,101,697	 (result discarded)
12464064.000000	: iteration 14: start=  204164, BFS took 	0.002107	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	31,020,159,299	, TEPS=	330,306,423	 (result discarded)
12464064.000000	: iteration 15: start=  181875, BFS took 	0.003674	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	17,790,796,099	, TEPS=	189,438,557	 (result discarded)
12464064.000000	: iteration 16: start=  352500, BFS took 	0.002591	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	25,228,321,329	, TEPS=	268,634,229	 (result discarded)
12464064.000000	: iteration 17: start=  208826, BFS took 	0.002396	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	27,279,220,685	, TEPS=	290,472,454	 (result discarded)
12464064.000000	: iteration 18: start=  492391, BFS took 	0.004868	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	13,427,180,325	, TEPS=	142,974,246	 (result discarded)
12464064.000000	: iteration 19: start=  283589, BFS took 	0.001357	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	48,173,636,951	, TEPS=	512,958,736	 (result discarded)
12464064.000000	: iteration 20: start=  445429, BFS took 	0.003838	s, covered 	696003	 edges, discovered 	6	 verts, TEPS incl. filtered edges=	17,030,448,992	, TEPS=	181,342,288	 (result discarded)
12464064.000000	: iteration 21: start=  220630, BFS took 	0.003723	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	17,557,231,372	, TEPS=	186,951,531	 (result discarded)
12464064.000000	: iteration 22: start=  164881, BFS took 	0.001696	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	38,542,973,132	, TEPS=	410,410,258	 (result discarded)
12464064.000000	: iteration 23: start=  360644, BFS took 	0.002420	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	27,010,459,890	, TEPS=	287,610,656	 (result discarded)
12464064.000000	: iteration 24: start=  276079, BFS took 	0.003412	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	19,157,023,820	, TEPS=	203,986,315	 (result discarded)
12464064.000000	: iteration 25: start=  107607, BFS took 	0.001385	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	47,195,071,077	, TEPS=	502,538,847	 (result discarded)
12464064.000000	: iteration 26: start=  233397, BFS took 	0.003609	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	18,111,658,049	, TEPS=	192,855,134	 (result discarded)
12464064.000000	: iteration 27: start=  462169, BFS took 	0.004145	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	15,768,789,134	, TEPS=	167,907,981	 (result discarded)
12464064.000000	: iteration 28: start=  120830, BFS took 	0.002554	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	25,593,368,921	, TEPS=	272,521,300	 (result discarded)
12464064.000000	: iteration 29: start=   14414, BFS took 	0.001596	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	40,955,507,602	, TEPS=	436,099,218	 (result discarded)
12464064.000000	: iteration 30: start=  281272, BFS took 	0.003656	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	17,877,806,839	, TEPS=	190,365,058	 (result discarded)
12464064.000000	: iteration 31: start=  352879, BFS took 	0.001354	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	48,275,430,161	, TEPS=	514,042,642	 (result discarded)
12464064.000000	: iteration 32: start=  481035, BFS took 	0.002798	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	23,362,263,987	, TEPS=	248,764,223	 (result discarded)
12464064.000000	: iteration 33: start=  219635, BFS took 	0.005053	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	12,936,166,087	, TEPS=	137,745,867	 (result discarded)
12464064.000000	: iteration 34: start=  240635, BFS took 	0.002710	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	24,120,725,663	, TEPS=	256,840,415	 (result discarded)
12464064.000000	: iteration 35: start=  294049, BFS took 	0.001578	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	41,425,833,769	, TEPS=	441,107,308	 (result discarded)
12464064.000000	: iteration 36: start=  226684, BFS took 	0.414682	s, covered 	696003	 edges, discovered 	78420	 verts, TEPS incl. filtered edges=	157,624,246	, TEPS=	1,678,402	 
12464064.000000	: iteration 37: start=   73888, BFS took 	0.001522	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	42,944,261,887	, TEPS=	457,275,715	 (result discarded)
12464064.000000	: iteration 38: start=  494280, BFS took 	0.003780	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	17,292,555,057	, TEPS=	184,133,226	 (result discarded)
12464064.000000	: iteration 39: start=  104264, BFS took 	0.001584	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	41,269,933,447	, TEPS=	439,447,262	 (result discarded)
12464064.000000	: iteration 40: start=  409681, BFS took 	0.003386	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	19,304,053,505	, TEPS=	205,551,905	 (result discarded)
12464064.000000	: iteration 41: start=  421447, BFS took 	0.001323	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	49,406,409,783	, TEPS=	526,085,450	 (result discarded)
12464064.000000	: iteration 42: start=  376828, BFS took 	0.006647	s, covered 	696003	 edges, discovered 	16	 verts, TEPS incl. filtered edges=	9,833,787,721	, TEPS=	104,711,365	 (result discarded)
12464064.000000	: iteration 43: start=  509614, BFS took 	0.005789	s, covered 	696003	 edges, discovered 	8	 verts, TEPS incl. filtered edges=	11,290,975,161	, TEPS=	120,227,674	 (result discarded)
12464064.000000	: iteration 44: start=  422506, BFS took 	0.001287	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	50,788,471,265	, TEPS=	540,801,809	 (result discarded)
12464064.000000	: iteration 45: start=  164961, BFS took 	0.002797	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	23,368,237,972	, TEPS=	248,827,835	 (result discarded)
12464064.000000	: iteration 46: start=   48842, BFS took 	0.064847	s, covered 	696003	 edges, discovered 	78410	 verts, TEPS incl. filtered edges=	1,007,971,557	, TEPS=	10,733,003	 
12464064.000000	: iteration 47: start=  364382, BFS took 	0.001071	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	61,032,094,365	, TEPS=	649,877,152	 (result discarded)
12464064.000000	: iteration 48: start=  272713, BFS took 	0.061095	s, covered 	696003	 edges, discovered 	78398	 verts, TEPS incl. filtered edges=	1,069,873,553	, TEPS=	11,392,143	 
12464064.000000	: iteration 49: start=  461260, BFS took 	0.004374	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	14,943,648,091	, TEPS=	159,121,779	 (result discarded)
12464064.000000	: iteration 50: start=  455276, BFS took 	0.001275	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	51,263,307,383	, TEPS=	545,857,922	 (result discarded)
12464064.000000	: iteration 51: start=  470848, BFS took 	0.065414	s, covered 	696003	 edges, discovered 	78418	 verts, TEPS incl. filtered edges=	999,235,210	, TEPS=	10,639,977	 
12464064.000000	: iteration 52: start=  436395, BFS took 	0.003874	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	16,872,187,081	, TEPS=	179,657,096	 (result discarded)
12464064.000000	: iteration 53: start=   44760, BFS took 	0.002826	s, covered 	696003	 edges, discovered 	4	 verts, TEPS incl. filtered edges=	23,129,685,977	, TEPS=	246,287,704	 (result discarded)
12464064.000000	: iteration 54: start=  436636, BFS took 	0.002577	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	25,363,693,948	, TEPS=	270,075,693	 (result discarded)
12464064.000000	: iteration 55: start=   20555, BFS took 	0.066821	s, covered 	696003	 edges, discovered 	78397	 verts, TEPS incl. filtered edges=	978,196,390	, TEPS=	10,415,953	 
12464064.000000	: iteration 56: start=  143711, BFS took 	0.002604	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	25,101,278,876	, TEPS=	267,281,465	 (result discarded)
12464064.000000	: iteration 57: start=   89384, BFS took 	0.000967	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	67,592,743,562	, TEPS=	719,735,741	 (result discarded)
12464064.000000	: iteration 58: start=   31180, BFS took 	0.003608	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	18,116,445,376	, TEPS=	192,906,110	 (result discarded)
12464064.000000	: iteration 59: start=  462183, BFS took 	0.003073	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	21,270,553,796	, TEPS=	226,491,439	 (result discarded)
12464064.000000	: iteration 60: start=  352911, BFS took 	0.061469	s, covered 	696003	 edges, discovered 	78401	 verts, TEPS incl. filtered edges=	1,063,362,686	, TEPS=	11,322,815	 
12464064.000000	: iteration 61: start=   51761, BFS took 	0.003374	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	19,372,256,069	, TEPS=	206,278,135	 (result discarded)
12464064.000000	: iteration 62: start=  312141, BFS took 	0.001888	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	34,620,048,982	, TEPS=	368,638,485	 (result discarded)
12464064.000000	: iteration 63: start=  221636, BFS took 	0.061852	s, covered 	696003	 edges, discovered 	78400	 verts, TEPS incl. filtered edges=	1,056,775,770	, TEPS=	11,252,676	 
12464064.000000	: iteration 64: start=  353504, BFS took 	0.003920	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	16,675,151,626	, TEPS=	177,559,039	 (result discarded)
12464064.000000	: iteration 65: start=  504155, BFS took 	0.002707	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	24,146,218,767	, TEPS=	257,111,869	 (result discarded)
12464064.000000	: iteration 66: start=  216731, BFS took 	0.002814	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	23,227,668,210	, TEPS=	247,331,031	 (result discarded)
12464064.000000	: iteration 67: start=  280615, BFS took 	0.005250	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	12,450,325,517	, TEPS=	132,572,577	 (result discarded)
12464064.000000	: iteration 68: start=  103974, BFS took 	0.002297	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	28,457,148,421	, TEPS=	303,015,171	 (result discarded)
12464064.000000	: iteration 69: start=  364148, BFS took 	0.001595	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	40,979,995,200	, TEPS=	436,359,965	 (result discarded)
12464064.000000	: iteration 70: start=  152437, BFS took 	0.005040	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	12,969,211,783	, TEPS=	138,097,741	 (result discarded)
12464064.000000	: iteration 71: start=  166061, BFS took 	0.003879	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	16,850,409,827	, TEPS=	179,425,210	 (result discarded)
12464064.000000	: iteration 72: start=   74800, BFS took 	0.064136	s, covered 	696003	 edges, discovered 	78400	 verts, TEPS incl. filtered edges=	1,019,145,178	, TEPS=	10,851,981	 
12464064.000000	: iteration 73: start=  361318, BFS took 	0.002069	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	31,592,091,252	, TEPS=	336,396,423	 (result discarded)
12464064.000000	: iteration 74: start=  412273, BFS took 	0.003967	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	16,477,711,737	, TEPS=	175,456,675	 (result discarded)
12464064.000000	: iteration 75: start=  439279, BFS took 	0.003014	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	21,687,854,433	, TEPS=	230,934,907	 (result discarded)
12464064.000000	: iteration 76: start=  217127, BFS took 	0.068557	s, covered 	696003	 edges, discovered 	78398	 verts, TEPS incl. filtered edges=	953,424,174	, TEPS=	10,152,176	 
12464064.000000	: iteration 77: start=    9625, BFS took 	0.005330	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	12,263,751,638	, TEPS=	130,585,916	 (result discarded)
12464064.000000	: iteration 78: start=   17985, BFS took 	0.002673	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	24,454,211,746	, TEPS=	260,391,416	 (result discarded)
12464064.000000	: iteration 79: start=  394815, BFS took 	0.068986	s, covered 	696003	 edges, discovered 	78399	 verts, TEPS incl. filtered edges=	947,493,054	, TEPS=	10,089,021	 
12464064.000000	: iteration 80: start=  328438, BFS took 	0.003981	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	16,418,503,287	, TEPS=	174,826,216	 (result discarded)
12464064.000000	: iteration 81: start=  520456, BFS took 	0.001626	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	40,198,851,596	, TEPS=	428,042,253	 (result discarded)
12464064.000000	: iteration 82: start=  347705, BFS took 	0.003011	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	21,708,462,102	, TEPS=	231,154,340	 (result discarded)
12464064.000000	: iteration 83: start=  393773, BFS took 	0.005206	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	12,555,237,584	, TEPS=	133,689,694	 (result discarded)
12464064.000000	: iteration 84: start=  157103, BFS took 	0.003270	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	19,989,512,788	, TEPS=	212,850,759	 (result discarded)
12464064.000000	: iteration 85: start=  147603, BFS took 	0.001717	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	38,071,957,768	, TEPS=	405,394,829	 (result discarded)
12464064.000000	: iteration 86: start=  234809, BFS took 	0.064335	s, covered 	696003	 edges, discovered 	78399	 verts, TEPS incl. filtered edges=	1,015,995,285	, TEPS=	10,818,441	 
12464064.000000	: iteration 87: start=  415412, BFS took 	0.001174	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	55,666,226,982	, TEPS=	592,740,744	 (result discarded)
12464064.000000	: iteration 88: start=  116908, BFS took 	0.001156	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	56,538,702,389	, TEPS=	602,030,968	 (result discarded)
12464064.000000	: iteration 89: start=   54329, BFS took 	0.003899	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	16,763,860,088	, TEPS=	178,503,617	 (result discarded)
12464064.000000	: iteration 90: start=   38612, BFS took 	0.002643	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	24,732,175,722	, TEPS=	263,351,210	 (result discarded)
12464064.000000	: iteration 91: start=  235734, BFS took 	0.001458	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	44,833,388,043	, TEPS=	477,391,360	 (result discarded)
12464064.000000	: iteration 92: start=  246969, BFS took 	0.005239	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	12,476,388,818	, TEPS=	132,850,103	 (result discarded)
12464064.000000	: iteration 93: start=  478211, BFS took 	0.001751	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	37,330,632,882	, TEPS=	397,501,112	 (result discarded)
12464064.000000	: iteration 94: start=   50617, BFS took 	0.001563	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	41,823,976,794	, TEPS=	445,346,783	 (result discarded)
12464064.000000	: iteration 95: start=  154534, BFS took 	0.004715	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	13,863,074,832	, TEPS=	147,615,704	 (result discarded)
12464064.000000	: iteration 96: start=  475460, BFS took 	0.062814	s, covered 	696003	 edges, discovered 	78406	 verts, TEPS incl. filtered edges=	1,040,594,880	, TEPS=	11,080,380	 
12464064.000000	: iteration 97: start=  151461, BFS took 	0.001497	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	43,662,393,357	, TEPS=	464,922,466	 (result discarded)
12464064.000000	: iteration 98: start=   62890, BFS took 	0.001276	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	51,224,994,000	, TEPS=	545,449,956	 (result discarded)
12464064.000000	: iteration 99: start=   68436, BFS took 	0.005320	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	12,286,285,197	, TEPS=	130,825,856	 (result discarded)
12464064.000000	: iteration 100: start=  276211, BFS took 	0.003252	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	20,099,425,798	, TEPS=	214,021,126	 (result discarded)
12464064.000000	: iteration 101: start=   10193, BFS took 	0.001889	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	34,602,570,729	, TEPS=	368,452,374	 (result discarded)
12464064.000000	: iteration 102: start=   44012, BFS took 	0.070606	s, covered 	696003	 edges, discovered 	78403	 verts, TEPS incl. filtered edges=	925,756,029	, TEPS=	9,857,562	 
12464064.000000	: iteration 103: start=  357284, BFS took 	0.001520	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	42,998,144,273	, TEPS=	457,849,461	 (result discarded)
12464064.000000	: iteration 104: start=  482561, BFS took 	0.001372	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	47,637,909,276	, TEPS=	507,254,242	 (result discarded)
12464064.000000	: iteration 105: start=  111383, BFS took 	0.004402	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	14,848,146,007	, TEPS=	158,104,861	 (result discarded)
12464064.000000	: iteration 106: start=  479186, BFS took 	0.001990	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	32,848,809,955	, TEPS=	349,778,117	 (result discarded)
12464064.000000	: iteration 107: start=  139762, BFS took 	0.001788	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	36,554,155,718	, TEPS=	389,233,088	 (result discarded)
12464064.000000	: iteration 108: start=  157332, BFS took 	0.005963	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	10,961,423,689	, TEPS=	116,718,570	 (result discarded)
12464064.000000	: iteration 109: start=  258724, BFS took 	0.062446	s, covered 	696003	 edges, discovered 	78398	 verts, TEPS incl. filtered edges=	1,046,729,184	, TEPS=	11,145,699	 
12464064.000000	: iteration 110: start=  307575, BFS took 	0.004688	s, covered 	696003	 edges, discovered 	4	 verts, TEPS incl. filtered edges=	13,942,743,624	, TEPS=	148,464,027	 (result discarded)
12464064.000000	: iteration 111: start=   28085, BFS took 	0.009428	s, covered 	696003	 edges, discovered 	15	 verts, TEPS incl. filtered edges=	6,932,939,709	, TEPS=	73,822,783	 (result discarded)
12464064.000000	: iteration 112: start=  297850, BFS took 	0.001527	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	42,803,461,028	, TEPS=	455,776,450	 (result discarded)
12464064.000000	: iteration 113: start=  302169, BFS took 	0.002873	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	22,751,549,202	, TEPS=	242,261,258	 (result discarded)
12464064.000000	: iteration 114: start=  323127, BFS took 	0.003767	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	17,351,656,195	, TEPS=	184,762,542	 (result discarded)
12464064.000000	: iteration 115: start=   77226, BFS took 	0.010288	s, covered 	696003	 edges, discovered 	60	 verts, TEPS incl. filtered edges=	6,353,414,008	, TEPS=	67,651,923	 (result discarded)
12464064.000000	: iteration 116: start=  503442, BFS took 	0.002933	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	22,285,495,682	, TEPS=	237,298,664	 (result discarded)
12464064.000000	: iteration 117: start=  310162, BFS took 	0.004018	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	16,267,499,429	, TEPS=	173,218,309	 (result discarded)
12464064.000000	: iteration 118: start=  137358, BFS took 	0.002746	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	23,802,410,825	, TEPS=	253,450,960	 (result discarded)
12464064.000000	: iteration 119: start=  368296, BFS took 	0.002814	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	23,227,668,210	, TEPS=	247,331,031	 (result discarded)
12464064.000000	: iteration 120: start=  121587, BFS took 	0.007751	s, covered 	696003	 edges, discovered 	5	 verts, TEPS incl. filtered edges=	8,432,979,633	, TEPS=	89,795,391	 (result discarded)
12464064.000000	: iteration 121: start=   53860, BFS took 	0.002531	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	25,824,808,580	, TEPS=	274,985,697	 (result discarded)
12464064.000000	: iteration 122: start=  280764, BFS took 	0.001372	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	47,637,909,276	, TEPS=	507,254,242	 (result discarded)
12464064.000000	: iteration 123: start=  217925, BFS took 	0.004088	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	15,988,579,220	, TEPS=	170,248,333	 (result discarded)
12464064.000000	: iteration 124: start=  499970, BFS took 	0.001383	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	47,260,156,505	, TEPS=	503,231,885	 (result discarded)
12464064.000000	: iteration 125: start=  365475, BFS took 	0.001440	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	45,390,094,021	, TEPS=	483,319,232	 (result discarded)
12464064.000000	: iteration 126: start=  259506, BFS took 	0.061904	s, covered 	696003	 edges, discovered 	78404	 verts, TEPS incl. filtered edges=	1,055,892,560	, TEPS=	11,243,272	 

BFS execution times (PythonSR_SejitsFilter_OTF)
            min_PythonSR_SejitsFilter_OTFtime	12464064.000000	: 	6.10949993133544922e-02
  firstquartile_PythonSR_SejitsFilter_OTFtime	12464064.000000	: 	6.20394349098205566e-02
         median_PythonSR_SejitsFilter_OTFtime	12464064.000000	: 	6.45909309387207031e-02
  thirdquartile_PythonSR_SejitsFilter_OTFtime	12464064.000000	: 	6.81229829788208008e-02
            max_PythonSR_SejitsFilter_OTFtime	12464064.000000	: 	4.14681911468505859e-01
           mean_PythonSR_SejitsFilter_OTFtime	12464064.000000	: 	8.66384357213973999e-02
         stddev_PythonSR_SejitsFilter_OTFtime	12464064.000000	: 	8.75254762382608187e-02
          total_PythonSR_SejitsFilter_OTFtime	12464064.000000	: 	1.386215e+00

number of edges traversed OTF
            min_PythonSR_SejitsFilter_OTFnedge	12464064.000000	: 	6.96003000000000000e+05
  firstquartile_PythonSR_SejitsFilter_OTFnedge	12464064.000000	: 	6.96003000000000000e+05
         median_PythonSR_SejitsFilter_OTFnedge	12464064.000000	: 	6.96003000000000000e+05
  thirdquartile_PythonSR_SejitsFilter_OTFnedge	12464064.000000	: 	6.96003000000000000e+05
            max_PythonSR_SejitsFilter_OTFnedge	12464064.000000	: 	6.96003000000000000e+05
           mean_PythonSR_SejitsFilter_OTFnedge	12464064.000000	: 	6.96003000000000000e+05
         stddev_PythonSR_SejitsFilter_OTFnedge	12464064.000000	: 	0.00000000000000000e+00
          total_PythonSR_SejitsFilter_OTFnedge	12464064.000000	: 	1.113605e+07

TEPS (PythonSR_SejitsFilter_OTF)
            min_PythonSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	1.67840212160510360e+06
  firstquartile_PythonSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	1.02181207762357630e+07
         median_PythonSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	1.07757223581001554e+07
  thirdquartile_PythonSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	1.12188790158475265e+07
            max_PythonSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	1.13921435112916641e+07
  harmonic_mean_PythonSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	8.03342066606710199e+06
harmonic_stddev_PythonSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	1.57898487904842186e+05

TEPS including filtered edges (PythonSR_SejitsFilter_OTF)
            min_IncFiltered_PythonSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	1.57624246904158115e+08
  firstquartile_IncFiltered_PythonSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	9.59617228432485819e+08
         median_IncFiltered_PythonSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	1.01198342142197561e+09
  thirdquartile_IncFiltered_PythonSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	1.05360171631020629e+09
            max_IncFiltered_PythonSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	1.06987355323060596e+09
  harmonic_mean_IncFiltered_PythonSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	7.54444877215815663e+08
harmonic_stddev_IncFiltered_PythonSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	1.48287647655642666e+07
Total runtime for pso on 1246406400% is	1483.779708	s.

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef
{
  double myfunc(const Obj2 &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_Obj2double_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_bfbd93b78f3801787b39b750cbda67ef;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101
{
  double myfunc(const double &x, const double &y)
  {
    return y;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_aafb9d1d9f0662d21fe8c33bafdbc101;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
Created SEJITS filter for 	1246406400	% in	0.037983	s.
--Generating starting verts

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_f478003faf74267d41b8a2b1eb850b07
{
  double myfunc(const double &x, const double &y)
  {
    return x;
  }
  
                        

            PyObject* get_function()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryFunctionObj *");

              BinaryFunctionObj_SEJITS* retf = new BinaryFunctionObj_SEJITS(Py_None);
              retf->customFunc_doubledouble_double = &myfunc;
                              
              BinaryFunctionObj* retO = new BinaryFunctionObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_f478003faf74267d41b8a2b1eb850b07;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_function", &get_function);
}

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6
{
  bool myfunc(const double &x, const double &y)
  {
    return y == -1;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::BinaryPredicateObj *");

              BinaryPredicateObj_SEJITS* retf = new BinaryPredicateObj_SEJITS();
              retf->customFuncDD = &myfunc;
                              
              BinaryPredicateObj* retO = new BinaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_e5c4ffa654fafac12ead4af3a19935c6;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj_Python()!!!
BinaryPredicateObj_SEJITS()!!!
BinaryPredicateObj()!!!

Source code for backend 'c++':
#include <boost/python.hpp>
#include "pyOperationsObj.h"
#include <tr1/memory>
#define COMBBLAS_TR1

namespace private_namespace_57bcccb429bfcd84817426270dd8d33c
{
  bool myfunc(const Obj2 &e)
  {
    if ((e.count > 0 && e.latest < 1246406400))
      return true;
    else
      return false;
  }
  
                        

            PyObject* get_predicate()
            {
              using namespace op;
              swig_module_info* module = SWIG_Python_GetModule();

              swig_type_info* ty = SWIG_TypeQueryModule(module, module, "op::UnaryPredicateObj *");

              UnaryPredicateObj_SEJITS* retf = new UnaryPredicateObj_SEJITS();
              retf->customFuncO2 = &myfunc;
                              
              UnaryPredicateObj* retO = new UnaryPredicateObj();
              retO->worker = *retf;

              PyObject* ret_obj = SWIG_NewPointerObj((void*)(retO), ty, SWIG_POINTER_OWN | 0);
              
              return ret_obj;
            }
}

using namespace private_namespace_57bcccb429bfcd84817426270dd8d33c;

BOOST_PYTHON_MODULE(module)
{
  boost::python::def("myfunc", &myfunc);
  boost::python::def("get_predicate", &get_predicate);
}
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj_Python()!!!
UnaryPredicateObj_SEJITS()!!!
UnaryPredicateObj()!!!
Generated starting verts in 32.874228s.
--Doing BFS
12464064.000000	: iteration  1: start=  219486, BFS took 	0.003681	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	17,757,378,579	, TEPS=	189,082,723	 (result discarded)
12464064.000000	: iteration  2: start=  524837, BFS took 	0.003734	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	17,504,543,984	, TEPS=	186,390,509	 (result discarded)
12464064.000000	: iteration  3: start=  379120, BFS took 	0.003998	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	16,348,987,291	, TEPS=	174,086,001	 (result discarded)
12464064.000000	: iteration  4: start=  490822, BFS took 	0.001551	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	42,145,452,404	, TEPS=	448,769,894	 (result discarded)
12464064.000000	: iteration  5: start=      60, BFS took 	0.001175	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	55,621,052,523	, TEPS=	592,259,721	 (result discarded)
12464064.000000	: iteration  6: start=   67434, BFS took 	0.003976	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	16,440,163,581	, TEPS=	175,056,858	 (result discarded)
12464064.000000	: iteration  7: start=  159123, BFS took 	0.003018	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	21,658,727,120	, TEPS=	230,624,756	 (result discarded)
12464064.000000	: iteration  8: start=  525814, BFS took 	0.001386	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	47,162,595,542	, TEPS=	502,193,044	 (result discarded)
12464064.000000	: iteration  9: start=   77240, BFS took 	0.005383	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	12,142,624,142	, TEPS=	129,296,136	 (result discarded)
12464064.000000	: iteration 10: start=  124258, BFS took 	0.002844	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	22,984,252,841	, TEPS=	244,739,115	 (result discarded)
12464064.000000	: iteration 11: start=   48599, BFS took 	0.003158	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	20,697,279,774	, TEPS=	220,387,148	 (result discarded)
12464064.000000	: iteration 12: start=  208727, BFS took 	0.059696	s, covered 	696003	 edges, discovered 	78399	 verts, TEPS incl. filtered edges=	1,094,947,212	, TEPS=	11,659,130	 
12464064.000000	: iteration 13: start=   98032, BFS took 	0.002902	s, covered 	696003	 edges, discovered 	6	 verts, TEPS incl. filtered edges=	22,523,510,342	, TEPS=	239,833,073	 (result discarded)
12464064.000000	: iteration 14: start=  204164, BFS took 	0.005146	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	12,701,823,938	, TEPS=	135,250,563	 (result discarded)
12464064.000000	: iteration 15: start=  181875, BFS took 	0.001390	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	47,025,071,679	, TEPS=	500,728,673	 (result discarded)
12464064.000000	: iteration 16: start=  352500, BFS took 	0.002481	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	26,345,970,391	, TEPS=	280,535,091	 (result discarded)
12464064.000000	: iteration 17: start=  208826, BFS took 	0.002519	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	25,947,015,700	, TEPS=	276,286,973	 (result discarded)
12464064.000000	: iteration 18: start=  492391, BFS took 	0.004595	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	14,224,882,887	, TEPS=	151,468,280	 (result discarded)
12464064.000000	: iteration 19: start=  283589, BFS took 	0.001691	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	38,657,102,071	, TEPS=	411,625,517	 (result discarded)
12464064.000000	: iteration 20: start=  445429, BFS took 	0.003357	s, covered 	696003	 edges, discovered 	6	 verts, TEPS incl. filtered edges=	19,471,318,742	, TEPS=	207,332,966	 (result discarded)
12464064.000000	: iteration 21: start=  220630, BFS took 	0.003314	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	19,723,465,315	, TEPS=	210,017,853	 (result discarded)
12464064.000000	: iteration 22: start=  164881, BFS took 	0.001461	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	44,738,278,049	, TEPS=	476,378,617	 (result discarded)
12464064.000000	: iteration 23: start=  360644, BFS took 	0.002511	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	26,030,779,328	, TEPS=	277,178,899	 (result discarded)
12464064.000000	: iteration 24: start=  276079, BFS took 	0.003654	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	17,888,305,356	, TEPS=	190,476,847	 (result discarded)
12464064.000000	: iteration 25: start=  107607, BFS took 	0.001271	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	51,426,780,695	, TEPS=	547,598,605	 (result discarded)
12464064.000000	: iteration 26: start=  233397, BFS took 	0.003867	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	16,903,395,270	, TEPS=	179,989,405	 (result discarded)
12464064.000000	: iteration 27: start=  462169, BFS took 	0.003771	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	17,333,006,757	, TEPS=	184,563,960	 (result discarded)
12464064.000000	: iteration 28: start=  120830, BFS took 	0.002362	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	27,672,975,460	, TEPS=	294,665,203	 (result discarded)
12464064.000000	: iteration 29: start=   14414, BFS took 	0.001625	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	40,222,442,471	, TEPS=	428,293,451	 (result discarded)
12464064.000000	: iteration 30: start=  281272, BFS took 	0.003693	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	17,698,913,356	, TEPS=	188,460,178	 (result discarded)
12464064.000000	: iteration 31: start=  352879, BFS took 	0.001226	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	53,317,029,927	, TEPS=	567,726,209	 (result discarded)
12464064.000000	: iteration 32: start=  481035, BFS took 	0.002541	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	25,725,454,432	, TEPS=	273,927,762	 (result discarded)
12464064.000000	: iteration 33: start=  219635, BFS took 	0.004887	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	13,375,428,984	, TEPS=	142,423,192	 (result discarded)
12464064.000000	: iteration 34: start=  240635, BFS took 	0.002504	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	26,102,653,326	, TEPS=	277,944,222	 (result discarded)
12464064.000000	: iteration 35: start=  294049, BFS took 	0.004147	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	15,762,442,815	, TEPS=	167,840,405	 (result discarded)
12464064.000000	: iteration 36: start=  226684, BFS took 	0.053795	s, covered 	696003	 edges, discovered 	78420	 verts, TEPS incl. filtered edges=	1,215,058,891	, TEPS=	12,938,094	 
12464064.000000	: iteration 37: start=   73888, BFS took 	0.001094	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	59,755,049,670	, TEPS=	636,279,025	 (result discarded)
12464064.000000	: iteration 38: start=  494280, BFS took 	0.003721	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	17,566,231,043	, TEPS=	187,047,361	 (result discarded)
12464064.000000	: iteration 39: start=  104264, BFS took 	0.001608	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	40,645,836,603	, TEPS=	432,801,803	 (result discarded)
12464064.000000	: iteration 40: start=  409681, BFS took 	0.001415	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	46,193,120,116	, TEPS=	491,869,952	 (result discarded)
12464064.000000	: iteration 41: start=  421447, BFS took 	0.003488	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	18,739,314,278	, TEPS=	199,538,493	 (result discarded)
12464064.000000	: iteration 42: start=  376828, BFS took 	0.006369	s, covered 	696003	 edges, discovered 	16	 verts, TEPS incl. filtered edges=	10,263,024,291	, TEPS=	109,281,928	 (result discarded)
12464064.000000	: iteration 43: start=  509614, BFS took 	0.003520	s, covered 	696003	 edges, discovered 	8	 verts, TEPS incl. filtered edges=	18,569,233,804	, TEPS=	197,727,456	 (result discarded)
12464064.000000	: iteration 44: start=  422506, BFS took 	0.003491	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	18,723,956,282	, TEPS=	199,374,960	 (result discarded)
12464064.000000	: iteration 45: start=  164961, BFS took 	0.002421	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	26,999,819,567	, TEPS=	287,497,357	 (result discarded)
12464064.000000	: iteration 46: start=   48842, BFS took 	0.051574	s, covered 	696003	 edges, discovered 	78410	 verts, TEPS incl. filtered edges=	1,267,381,518	, TEPS=	13,495,232	 
12464064.000000	: iteration 47: start=  364382, BFS took 	0.003454	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	18,924,288,526	, TEPS=	201,508,122	 (result discarded)
12464064.000000	: iteration 48: start=  272713, BFS took 	0.056387	s, covered 	696003	 edges, discovered 	78398	 verts, TEPS incl. filtered edges=	1,159,203,091	, TEPS=	12,343,335	 
12464064.000000	: iteration 49: start=  461260, BFS took 	0.002052	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	31,852,697,558	, TEPS=	339,171,391	 (result discarded)
12464064.000000	: iteration 50: start=  455276, BFS took 	0.003474	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	18,815,192,360	, TEPS=	200,346,453	 (result discarded)
12464064.000000	: iteration 51: start=  470848, BFS took 	0.053016	s, covered 	696003	 edges, discovered 	78418	 verts, TEPS incl. filtered edges=	1,232,905,065	, TEPS=	13,128,122	 
12464064.000000	: iteration 52: start=  436395, BFS took 	0.001096	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	59,638,061,320	, TEPS=	635,033,318	 (result discarded)
12464064.000000	: iteration 53: start=   44760, BFS took 	0.004752	s, covered 	696003	 edges, discovered 	4	 verts, TEPS incl. filtered edges=	13,755,264,055	, TEPS=	146,467,721	 (result discarded)
12464064.000000	: iteration 54: start=  436636, BFS took 	0.002910	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	22,460,770,759	, TEPS=	239,165,014	 (result discarded)
12464064.000000	: iteration 55: start=   20555, BFS took 	0.057159	s, covered 	696003	 edges, discovered 	78397	 verts, TEPS incl. filtered edges=	1,143,546,678	, TEPS=	12,176,623	 
12464064.000000	: iteration 56: start=  143711, BFS took 	0.002156	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	30,316,948,787	, TEPS=	322,818,552	 (result discarded)
12464064.000000	: iteration 57: start=   89384, BFS took 	0.000966	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	67,659,468,876	, TEPS=	720,446,240	 (result discarded)
12464064.000000	: iteration 58: start=   31180, BFS took 	0.003455	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	18,919,064,791	, TEPS=	201,452,499	 (result discarded)
12464064.000000	: iteration 59: start=  462183, BFS took 	0.002758	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	23,699,530,419	, TEPS=	252,355,477	 (result discarded)
12464064.000000	: iteration 60: start=  352911, BFS took 	0.052939	s, covered 	696003	 edges, discovered 	78401	 verts, TEPS incl. filtered edges=	1,234,704,100	, TEPS=	13,147,279	 
12464064.000000	: iteration 61: start=   51761, BFS took 	0.003866	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	16,907,565,087	, TEPS=	180,033,806	 (result discarded)
12464064.000000	: iteration 62: start=  312141, BFS took 	0.001626	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	40,198,851,596	, TEPS=	428,042,253	 (result discarded)
12464064.000000	: iteration 63: start=  221636, BFS took 	0.054067	s, covered 	696003	 edges, discovered 	78400	 verts, TEPS incl. filtered edges=	1,208,945,367	, TEPS=	12,872,997	 
12464064.000000	: iteration 64: start=  353504, BFS took 	0.004007	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	16,312,022,841	, TEPS=	173,692,400	 (result discarded)
12464064.000000	: iteration 65: start=  504155, BFS took 	0.002578	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	25,354,311,281	, TEPS=	269,975,785	 (result discarded)
12464064.000000	: iteration 66: start=  216731, BFS took 	0.002512	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	26,020,896,724	, TEPS=	277,073,668	 (result discarded)
12464064.000000	: iteration 67: start=  280615, BFS took 	0.005318	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	12,290,691,647	, TEPS=	130,872,777	 (result discarded)
12464064.000000	: iteration 68: start=  103974, BFS took 	0.002673	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	24,454,211,746	, TEPS=	260,391,416	 (result discarded)
12464064.000000	: iteration 69: start=  364148, BFS took 	0.001873	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	34,897,679,211	, TEPS=	371,594,725	 (result discarded)
12464064.000000	: iteration 70: start=  152437, BFS took 	0.005062	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	12,913,012,476	, TEPS=	137,499,324	 (result discarded)
12464064.000000	: iteration 71: start=  166061, BFS took 	0.003649	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	17,912,849,911	, TEPS=	190,738,201	 (result discarded)
12464064.000000	: iteration 72: start=   74800, BFS took 	0.054559	s, covered 	696003	 edges, discovered 	78400	 verts, TEPS incl. filtered edges=	1,198,041,260	, TEPS=	12,756,888	 
12464064.000000	: iteration 73: start=  361318, BFS took 	0.004833	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	13,524,550,732	, TEPS=	144,011,058	 (result discarded)
12464064.000000	: iteration 74: start=  412273, BFS took 	0.001528	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	42,776,746,432	, TEPS=	455,491,990	 (result discarded)
12464064.000000	: iteration 75: start=  439279, BFS took 	0.002575	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	25,384,830,360	, TEPS=	270,300,756	 (result discarded)
12464064.000000	: iteration 76: start=  217127, BFS took 	0.060593	s, covered 	696003	 edges, discovered 	78398	 verts, TEPS incl. filtered edges=	1,078,734,931	, TEPS=	11,486,500	 
12464064.000000	: iteration 77: start=    9625, BFS took 	0.001988	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	32,880,327,163	, TEPS=	350,113,716	 (result discarded)
12464064.000000	: iteration 78: start=   17985, BFS took 	0.001841	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	35,503,259,244	, TEPS=	378,043,015	 (result discarded)
12464064.000000	: iteration 79: start=  394815, BFS took 	0.059058	s, covered 	696003	 edges, discovered 	78399	 verts, TEPS incl. filtered edges=	1,106,776,021	, TEPS=	11,785,085	 
12464064.000000	: iteration 80: start=  328438, BFS took 	0.001036	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	63,096,931,619	, TEPS=	671,863,789	 (result discarded)
12464064.000000	: iteration 81: start=  520456, BFS took 	0.001090	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	59,977,284,596	, TEPS=	638,645,409	 (result discarded)
12464064.000000	: iteration 82: start=  347705, BFS took 	0.001951	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	33,503,136,733	, TEPS=	356,745,468	 (result discarded)
12464064.000000	: iteration 83: start=  393773, BFS took 	0.004929	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	13,261,557,001	, TEPS=	141,210,669	 (result discarded)
12464064.000000	: iteration 84: start=  157103, BFS took 	0.002446	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	26,723,478,690	, TEPS=	284,554,846	 (result discarded)
12464064.000000	: iteration 85: start=  147603, BFS took 	0.001573	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	41,557,703,181	, TEPS=	442,511,469	 (result discarded)
12464064.000000	: iteration 86: start=  234809, BFS took 	0.054789	s, covered 	696003	 edges, discovered 	78399	 verts, TEPS incl. filtered edges=	1,193,015,556	, TEPS=	12,703,374	 
12464064.000000	: iteration 87: start=  415412, BFS took 	0.001053	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	62,082,465,554	, TEPS=	661,061,632	 (result discarded)
12464064.000000	: iteration 88: start=  116908, BFS took 	0.001024	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	63,831,470,986	, TEPS=	679,685,254	 (result discarded)
12464064.000000	: iteration 89: start=   54329, BFS took 	0.003613	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	18,091,340,100	, TEPS=	192,638,786	 (result discarded)
12464064.000000	: iteration 90: start=   38612, BFS took 	0.002943	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	22,209,670,114	, TEPS=	236,491,264	 (result discarded)
12464064.000000	: iteration 91: start=  235734, BFS took 	0.001454	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	44,951,003,097	, TEPS=	478,643,739	 (result discarded)
12464064.000000	: iteration 92: start=  246969, BFS took 	0.005146	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	12,701,823,938	, TEPS=	135,250,563	 (result discarded)
12464064.000000	: iteration 93: start=  478211, BFS took 	0.001426	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	45,837,847,832	, TEPS=	488,086,969	 (result discarded)
12464064.000000	: iteration 94: start=   50617, BFS took 	0.001463	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	44,672,668,712	, TEPS=	475,680,001	 (result discarded)
12464064.000000	: iteration 95: start=  154534, BFS took 	0.005028	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	12,999,960,542	, TEPS=	138,425,158	 (result discarded)
12464064.000000	: iteration 96: start=  475460, BFS took 	0.051605	s, covered 	696003	 edges, discovered 	78406	 verts, TEPS incl. filtered edges=	1,266,614,465	, TEPS=	13,487,064	 
12464064.000000	: iteration 97: start=  151461, BFS took 	0.001042	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	62,735,965,191	, TEPS=	668,020,175	 (result discarded)
12464064.000000	: iteration 98: start=   62890, BFS took 	0.004088	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	15,988,579,220	, TEPS=	170,248,333	 (result discarded)
12464064.000000	: iteration 99: start=   68436, BFS took 	0.002430	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	26,899,153,050	, TEPS=	286,425,448	 (result discarded)
12464064.000000	: iteration 100: start=  276211, BFS took 	0.002696	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	24,244,443,569	, TEPS=	258,157,779	 (result discarded)
12464064.000000	: iteration 101: start=   10193, BFS took 	0.003682	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	17,751,629,622	, TEPS=	189,021,507	 (result discarded)
12464064.000000	: iteration 102: start=   44012, BFS took 	0.057487	s, covered 	696003	 edges, discovered 	78403	 verts, TEPS incl. filtered edges=	1,137,020,744	, TEPS=	12,107,134	 
12464064.000000	: iteration 103: start=  357284, BFS took 	0.001000	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	65,368,661,871	, TEPS=	696,053,449	 (result discarded)
12464064.000000	: iteration 104: start=  482561, BFS took 	0.003889	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	16,807,023,534	, TEPS=	178,963,227	 (result discarded)
12464064.000000	: iteration 105: start=  111383, BFS took 	0.001616	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	40,447,944,510	, TEPS=	430,694,624	 (result discarded)
12464064.000000	: iteration 106: start=  479186, BFS took 	0.001258	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	51,962,882,465	, TEPS=	553,307,082	 (result discarded)
12464064.000000	: iteration 107: start=  139762, BFS took 	0.003771	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	17,333,006,757	, TEPS=	184,563,960	 (result discarded)
12464064.000000	: iteration 108: start=  157332, BFS took 	0.002978	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	21,950,053,473	, TEPS=	233,726,834	 (result discarded)
12464064.000000	: iteration 109: start=  258724, BFS took 	0.051512	s, covered 	696003	 edges, discovered 	78398	 verts, TEPS incl. filtered edges=	1,268,906,667	, TEPS=	13,511,472	 
12464064.000000	: iteration 110: start=  307575, BFS took 	0.007347	s, covered 	696003	 edges, discovered 	4	 verts, TEPS incl. filtered edges=	8,896,552,696	, TEPS=	94,731,573	 (result discarded)
12464064.000000	: iteration 111: start=   28085, BFS took 	0.006449	s, covered 	696003	 edges, discovered 	15	 verts, TEPS incl. filtered edges=	10,135,163,323	, TEPS=	107,920,449	 (result discarded)
12464064.000000	: iteration 112: start=  297850, BFS took 	0.001459	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	44,796,759,458	, TEPS=	477,001,334	 (result discarded)
12464064.000000	: iteration 113: start=  302169, BFS took 	0.002613	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	25,014,248,894	, TEPS=	266,354,759	 (result discarded)
12464064.000000	: iteration 114: start=  323127, BFS took 	0.003912	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	16,708,688,925	, TEPS=	177,916,148	 (result discarded)
12464064.000000	: iteration 115: start=   77226, BFS took 	0.009372	s, covered 	696003	 edges, discovered 	60	 verts, TEPS incl. filtered edges=	6,974,386,727	, TEPS=	74,264,116	 (result discarded)
12464064.000000	: iteration 116: start=  503442, BFS took 	0.002523	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	25,905,335,716	, TEPS=	275,843,160	 (result discarded)
12464064.000000	: iteration 117: start=  310162, BFS took 	0.003360	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	19,453,357,545	, TEPS=	207,141,713	 (result discarded)
12464064.000000	: iteration 118: start=  137358, BFS took 	0.002643	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	24,729,944,785	, TEPS=	263,327,455	 (result discarded)
12464064.000000	: iteration 119: start=  368296, BFS took 	0.002389	s, covered 	696003	 edges, discovered 	3	 verts, TEPS incl. filtered edges=	27,360,894,998	, TEPS=	291,342,132	 (result discarded)
12464064.000000	: iteration 120: start=  121587, BFS took 	0.007006	s, covered 	696003	 edges, discovered 	5	 verts, TEPS incl. filtered edges=	9,329,799,826	, TEPS=	99,344,841	 (result discarded)
12464064.000000	: iteration 121: start=   53860, BFS took 	0.002641	s, covered 	696003	 edges, discovered 	2	 verts, TEPS incl. filtered edges=	24,750,037,725	, TEPS=	263,541,407	 (result discarded)
12464064.000000	: iteration 122: start=  280764, BFS took 	0.001287	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	50,788,471,265	, TEPS=	540,801,809	 (result discarded)
12464064.000000	: iteration 123: start=  217925, BFS took 	0.004130	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	15,827,050,449	, TEPS=	168,528,355	 (result discarded)
12464064.000000	: iteration 124: start=  499970, BFS took 	0.001335	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	48,965,202,337	, TEPS=	521,387,420	 (result discarded)
12464064.000000	: iteration 125: start=  365475, BFS took 	0.001582	s, covered 	696003	 edges, discovered 	1	 verts, TEPS incl. filtered edges=	41,313,467,132	, TEPS=	439,910,814	 (result discarded)
12464064.000000	: iteration 126: start=  259506, BFS took 	0.051841	s, covered 	696003	 edges, discovered 	78404	 verts, TEPS incl. filtered edges=	1,260,853,340	, TEPS=	13,425,719	 

BFS execution times (SejitsSR_SejitsFilter_OTF)
            min_SejitsSR_SejitsFilter_OTFtime	12464064.000000	: 	5.15120029449462891e-02
  firstquartile_SejitsSR_SejitsFilter_OTFtime	12464064.000000	: 	5.21154999732971191e-02
         median_SejitsSR_SejitsFilter_OTFtime	12464064.000000	: 	5.43129444122314453e-02
  thirdquartile_SejitsSR_SejitsFilter_OTFtime	12464064.000000	: 	5.74049949645996094e-02
            max_SejitsSR_SejitsFilter_OTFtime	12464064.000000	: 	6.05931282043457031e-02
           mean_SejitsSR_SejitsFilter_OTFtime	12464064.000000	: 	5.50048053264617920e-02
         stddev_SejitsSR_SejitsFilter_OTFtime	12464064.000000	: 	3.04110217454938792e-03
          total_SejitsSR_SejitsFilter_OTFtime	12464064.000000	: 	8.800769e-01

number of edges traversed OTF
            min_SejitsSR_SejitsFilter_OTFnedge	12464064.000000	: 	6.96003000000000000e+05
  firstquartile_SejitsSR_SejitsFilter_OTFnedge	12464064.000000	: 	6.96003000000000000e+05
         median_SejitsSR_SejitsFilter_OTFnedge	12464064.000000	: 	6.96003000000000000e+05
  thirdquartile_SejitsSR_SejitsFilter_OTFnedge	12464064.000000	: 	6.96003000000000000e+05
            max_SejitsSR_SejitsFilter_OTFnedge	12464064.000000	: 	6.96003000000000000e+05
           mean_SejitsSR_SejitsFilter_OTFnedge	12464064.000000	: 	6.96003000000000000e+05
         stddev_SejitsSR_SejitsFilter_OTFnedge	12464064.000000	: 	0.00000000000000000e+00
          total_SejitsSR_SejitsFilter_OTFnedge	12464064.000000	: 	1.113605e+07

TEPS (SejitsSR_SejitsFilter_OTF)
            min_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	1.14865005426487140e+07
  firstquartile_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	1.21245071937118955e+07
         median_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	1.28149429502176903e+07
  thirdquartile_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	1.33561094098028224e+07
            max_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	1.35114722823699303e+07
  harmonic_mean_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	1.26534944696034752e+07
harmonic_stddev_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	5.35664176437110873e+04

TEPS including filtered edges (SejitsSR_SejitsFilter_OTF)
            min_IncFiltered_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	1.07873493145237780e+09
  firstquartile_IncFiltered_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	1.13865222814734674e+09
         median_IncFiltered_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	1.20349331405520511e+09
  thirdquartile_IncFiltered_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	1.25431603081888533e+09
            max_IncFiltered_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	1.26890666763352275e+09
  harmonic_mean_IncFiltered_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	1.18833115783348894e+09
harmonic_stddev_IncFiltered_SejitsSR_SejitsFilter_OTF_TEPS	12464064.000000	: 	5.03059793106610328e+06
Total runtime for sso on 1246406400% is	1481.289681	s.
Total runtime for everything is		4479.188304
